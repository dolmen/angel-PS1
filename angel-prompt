#!/usr/bin/perl
use utf8;

#    Copyright © 2013 Olivier Mengué
#    Original source code is available at https://github.com/dolmen/angel-prompt
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.



use 5.008003;  # 5.010 is the sane minimum
use strict;
use warnings;

use Getopt::Long;
use File::Temp 'tmpnam';

binmode(STDOUT, ':encoding(utf8)');
binmode(STDERR, ':encoding(utf8)');

my $SHELL;
my $NAME = 'angel';
my $VERBOSE = 0;
my $SHELL_PPID = getppid();
my $TERM = $ENV{TERM};

my %SUPPORTED_SHELLS = map { ($_ => undef) } qw(bash zsh);

GetOptions(
    'shell=s' => \$SHELL,
    'name=s' => \$NAME,
    'v|verbose' => \$VERBOSE,
);


unless ($SHELL) {
    $SHELL = $ENV{SHELL};
    $SHELL =~ s{^.*/}{};
} else {
    $SHELL =~ s/^-//;
}

# The angel name must be a valid shell function identifier
# Note that '-' is allowed, even as a first char
$NAME =~ /^[-A-Z_][-A-Z_0-9]*$/si or die "invalid angel name";


my $FIFO_PATH = tmpnam().".$$";
my $FIFO_IN = "$FIFO_PATH.in";
my $FIFO_OUT = "$FIFO_PATH.out";

if (-t STDOUT) {
    die "TERM is not set\n" unless exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

    print "Copyright (C) 2013  Olivier Mengué\n",
          "This program comes with ABSOLUTELY NO WARRANTY;\n",
          "This is free software, and you are welcome to redistribute it\n",
          "under certain conditions;\n",
          "See \"sed -n '4,19{s/.//;p}' \$(which $0)\" for details.\n\n",
    print STDERR "usage: eval `angel-prompt --shell=\$0`\n";
    exit 1;
}

# *****************************************************************************
# Angel startup
# *****************************************************************************

# No terminal? This is not an interactive shell.
# So we don't install.
exit 0 unless -t STDIN && exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

require POSIX;
POSIX::mkfifo($FIFO_IN, 0600) or die "Can't create fifo $FIFO_IN: $!";
POSIX::mkfifo($FIFO_OUT, 0600) or die "Can't create fifo $FIFO_OUT: $!";

# The shell code will be evaluated with eval as a single line
# so statements must be properly terminated with ';'
# No shell comments allowed
print <<EOF;
[[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave;
APS1_PS1="\$PS1";
APS1_PROMPT_COMMAND="\$PROMPT_COMMAND";
angel-PS1()
{
    local err=\$?;
    [[ -e '$FIFO_IN' ]] || { $NAME leave ; return ; };
    printf '%s\\0%s\\0%s' "?=\$err" "PWD=\$PWD" > '$FIFO_IN' || { $NAME leave ; return ; };
    read PS1 < '$FIFO_OUT' || $NAME leave ;
    printf 'DEBUG> PS1=%q\\n' "\$PS1" ;
} ;
PROMPT_COMMAND=angel-PS1 ;
APS1_NAME=$NAME ;
$NAME()
{
    case "\$1" in
    leave|quit|go-away)
        PROMPT_COMMAND="\$APS1_PROMPT_COMMAND" ;
        PS1="\$APS1_PS1" ;
        kill \$APS1_PID 2>/dev/null ;
        rm -f -- '$FIFO_IN' '$FIFO_OUT' ;
        unset APS1_PS1 APS1_PID APS1_NAME ;
        unset -f $NAME angel-PS1 ;;
    mute|off)
        PROMPT_COMMAND="\$APS1_PROMPT_COMMAND" ;
        PS1="\$APS1_PS1" ;;
    unmute|on)
        PROMPT_COMMAND=angel-PS1 ;;
    *)
        echo 'What?' >&2 ;
        return 1 ;;
    esac ;
} ;
EOF
# TODO: exit trap to kill the daemon

close STDIN;

my $child = fork();
die if $child == -1;
if ($child) {
    # We don't want the fifos to be removed by the END block
    undef $FIFO_IN;
    undef $FIFO_OUT;
    print "APS1_PID=$child\n";
    print STDERR "angel-prompt $child installed.\n";
    exit 0;
}

# *****************************************************************************
# Angel forked
# *****************************************************************************

open STDIN, '+<', '/dev/null';
close STDOUT;
open STDOUT, '>', '/dev/null';


# Ignore ^C sent to the terminal
$SIG{INT} = sub {
    print STDERR "Ctrl+C !\n";
    #exit 0;
};
# Clean exits that will call our END block
$SIG{HUP} = $SIG{TERM} = sub { exit 0 };

# Terminal size change
# TODO: compute $COLUMNS and $LINES
#$SIG{WINCH} = sub { print STDERR "WINCH!\n" };


# *****************************************************************************
# Angel main loop
# *****************************************************************************
    for (;;) {
        my $FIFO;
        unless (open $FIFO, '<', $FIFO_IN) {
            redo if -e $FIFO_IN && -p _;
            last;
        }
        $_ = do { undef $/; <$FIFO> };
        close $FIFO;
        printf STDERR "DEBUG< %s\n", do { (my $tmp = $_) =~ s/\0/ /g; $tmp };

        my %opts = map { ( m/^(.*?)=(.*)/s ) } split /\0/;
        my $PWD = $opts{'PWD'};

        my $PS1 = (scalar localtime) . " $opts{'?'} \\w\\\$ ";

        open $FIFO, '>', $FIFO_OUT;
        # Escape the last space using bash PS1 encoding as 'read' removes spaces
        # at beginning and end of line
        (my $out = $PS1) =~ s/^ | $/\\040/g;
        # Escape \ as 'read' expands them
        $out =~ s/\\/\\\\/g;
        # Escape newlines
        $out =~ s/\n/\\\n/g;
        print $FIFO "$out\n";
        close $FIFO;
    }


END {
    no warnings 'uninitialized';
    unlink $FIFO_IN, $FIFO_OUT;
}

# vim:set et ts=8 sw=4 sts=4:
