#!/usr/bin/perl
use utf8;

#    Copyright © 2013 Olivier Mengué
#    Original source code is available at https://github.com/dolmen/angel-prompt
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.



use 5.008003;  # 5.010 is the sane minimum
use strict;
use warnings;

use Getopt::Long;
use File::Temp 'tmpnam';
use Encode ();

# Extact encoding name from the locale
my $ENCODING = do {
    # Shortcut for the most common case
    my $locale = $ENV{LC_ALL} || $ENV{LC_CTYPE} || $ENV{LANG};
    $locale =~ /\.UTF-8(?:@.)?/i
        ? 'UTF-8'
        : do {
            # warn "slow locale lookup...";
            require POSIX;
            POSIX::setlocale(POSIX::LC_CTYPE(), '');
            require I18N::Langinfo;
            eval { I18N::Langinfo::langinfo(I18N::Langinfo::CODESET()) }
                or do { warn $@; undef }
        }
};

# Decode @ARGV and encode STDOUT, STDERR
if ($ENCODING) {
    my $encoding_obj = Encode::find_encoding($ENCODING);
    map { $_ = $encoding_obj->decode($_) } @ARGV;
    binmode(STDOUT, ":encoding($ENCODING)");
    binmode(STDERR, ":encoding($ENCODING)");
}

my $SHELL;
my $NAME = 'angel';
my $VERBOSE = 0;
my $SHELL_PPID = getppid();
my $TERM = $ENV{TERM};

my %SUPPORTED_SHELLS = map { ($_ => undef) } qw(bash zsh);

sub terminfo ($;@); # Pre-declare for recursion

sub terminfo ($;@)
{
    my ($capability, @args) = @_;
    if (ref $capability) {
        for my $cap (@$capability) {
            my $res = terminfo $cap, @args;
            return $res if $res ne '';
        }
        return '';
    }
    open my $tput, '-|', '/usr/bin/tput', $capability, @args
        or return '';
    undef $/;
    scalar readline $tput
}

sub setaf ($) { terminfo [ qw(setaf AF) ], $_[0] }

my ($BLACK, $RED, $GREEN, $YELLOW, $BLUE, $MAGENTA, $CYAN, $GRAY) =
    map { setaf $_ } 0..7;
my $BOLD = terminfo [ qw(bold md) ];
my $NO_COLOR = terminfo [ qw(sgr0 me) ];
my ($B, $E) = ('\[', '\]');

GetOptions(
    'shell=s' => \$SHELL,
    'name=s' => \$NAME,
    'v|verbose' => \$VERBOSE,
);


unless ($SHELL) {
    $SHELL = $ENV{SHELL};
    $SHELL =~ s{^.*/}{};
} else {
    $SHELL =~ s/^-//;
}

# The angel name must be a valid shell function identifier
# Note that '-' is allowed, even as a first char
$NAME =~ /^[-A-Z_][-A-Z_0-9]*$/si or die "invalid angel name";


my $FIFO_PATH = tmpnam().".$$";
my $FIFO_IN = "$FIFO_PATH.in";
my $FIFO_OUT = "$FIFO_PATH.out";

if (-t STDOUT) {
    die "TERM is not set\n" unless exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

    unless ($ENCODING) {
        print STDERR "Encoding not set in locale. Please set LC_CTYPE.\n";
    } elsif ($ENCODING !~ /^UTF-/i) {
        # Get the canonical name
        $ENCODING = Encode::find_encoding($ENCODING)->name;
        print STDERR "Your locale is not set to a known Unicode encoding (such as 'UTF-8') but to '$ENCODING'. Please report your use case to the Angel Prompt developers.\n"
    }

    print "${RED}Red!${NO_COLOR}\n";

    print "Copyright (C) 2013  Olivier Mengué\n",
          "This program comes with ABSOLUTELY NO WARRANTY;\n",
          "This is free software, and you are welcome to redistribute it\n",
          "under certain conditions;\n",
          "See \"sed -n '4,19{s/.//;p}' \$(which $0)\" for details.\n\n",
    print STDERR "usage: eval `angel-prompt --shell=\$0`\n";
    exit 1;
}

# *****************************************************************************
# Angel startup
# *****************************************************************************

# No terminal? This is not an interactive shell.
# So we don't install.
exit 0 unless -t STDIN && exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

require POSIX;
POSIX::mkfifo($FIFO_IN, 0600) or die "Can't create fifo $FIFO_IN: $!";
POSIX::mkfifo($FIFO_OUT, 0600) or die "Can't create fifo $FIFO_OUT: $!";

# The shell code will be evaluated with eval as a single line
# so statements must be properly terminated with ';'
# No shell comments allowed
print <<EOF;
[[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave;
APS1_PS1="\$PS1";
APS1_PROMPT_COMMAND="\$PROMPT_COMMAND";
angel-PS1()
{
    local err=\$?;
    [[ -e '$FIFO_IN' ]] || { $NAME leave ; return ; };
    printf '%s\\0%s\\0%s' "?=\$err" "PWD=\$PWD" > '$FIFO_IN' || { $NAME leave ; return ; };
    read PS1 < '$FIFO_OUT' || $NAME leave ;
    printf 'DEBUG> PS1=%q\\n' "\$PS1" ;
} ;
PROMPT_COMMAND=angel-PS1 ;
APS1_NAME=$NAME ;
$NAME()
{
    case "\$1" in
    leave|quit|go-away)
        PROMPT_COMMAND="\$APS1_PROMPT_COMMAND" ;
        PS1="\$APS1_PS1" ;
        kill \$APS1_PID 2>/dev/null ;
        rm -f -- '$FIFO_IN' '$FIFO_OUT' ;
        unset APS1_PS1 APS1_PID APS1_NAME ;
        unset -f $NAME angel-PS1 ;;
    mute|off)
        PROMPT_COMMAND="\$APS1_PROMPT_COMMAND" ;
        PS1="\$APS1_PS1" ;;
    unmute|on)
        PROMPT_COMMAND=angel-PS1 ;;
    *)
        echo 'What?' >&2 ;
        return 1 ;;
    esac ;
} ;
EOF
# TODO: exit trap to kill the daemon

(my $TTYNAME = POSIX::ttyname(0)) =~ s{^/dev/}{};

close STDIN;

my $child = fork();
die if $child == -1;
if ($child) {
    # We don't want the fifos to be removed by the END block
    undef $FIFO_IN;
    undef $FIFO_OUT;
    print "APS1_PID=$child\n";
    print STDERR "angel-prompt $child installed.\n";
    exit 0;
}

# *****************************************************************************
# Angel forked
# *****************************************************************************

open STDIN, '+<', '/dev/null';
close STDOUT;
open STDOUT, '>', '/dev/null';


# Ignore ^C sent to the terminal
$SIG{INT} = sub {
    print STDERR "Ctrl+C !\n";
    #exit 0;
};
# Clean exits that will call our END block
$SIG{HUP} = $SIG{TERM} = sub { exit 0 };

# Terminal size change
# TODO: compute $COLUMNS and $LINES
#$SIG{WINCH} = sub { print STDERR "WINCH!\n" };

my $USER_MARK = $< ? "$B$BOLD$E\\\$$B$NO_COLOR$E" : "$B$BOLD$RED$E#$B$NO_COLOR$E";

# *****************************************************************************
# Angel main loop
# *****************************************************************************
    for (;;) {
        my $FIFO;
        unless (open $FIFO, "<:encoding($ENCODING)", $FIFO_IN) {
            redo if -e $FIFO_IN && -p _;
            last;
        }
        $_ = do { undef $/; <$FIFO> };
        close $FIFO;
        printf STDERR "DEBUG< %s\n", do { (my $tmp = $_) =~ s/\0/ /g; $tmp };

        my %opts = map { ( m/^(.*?)=(.*)/s ) } split /\0/;
        my $PWD = $opts{'PWD'};

        my $time = sprintf '%3$02d:%2$02d:%1$02d', localtime;
        my $err = $opts{'?'} == 0 ? '' : "$B$RED$E$opts{'?'}$B$NO_COLOR$E ";
        my $PS1 = "$B$BLUE$E$time$B${NO_COLOR}$E $TTYNAME \\w $err$USER_MARK ";

        open $FIFO, ">:encoding($ENCODING)", $FIFO_OUT;
        # Escape the last space using bash PS1 encoding as 'read' removes spaces
        # at beginning and end of line
        (my $out = $PS1) =~ s/^ | $/\\040/g;
        # Escape \ as 'read' expands them
        $out =~ s/\\/\\\\/g;
        # Escape newlines
        $out =~ s/\n/\\\n/g;
        print $FIFO "$out\n";
        close $FIFO;
    }


END {
    no warnings 'uninitialized';
    unlink $FIFO_IN, $FIFO_OUT;
}

# vim:set et ts=8 sw=4 sts=4:
