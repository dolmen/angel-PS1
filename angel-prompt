#!/usr/bin/perl

use 5.008003;  # 5.010 is the sane minimum
use strict;
use warnings;

use Getopt::Long;
use File::Temp 'tmpnam';
use POSIX qw(mkfifo);

my $SHELL;
my $SHELL_PPID = getppid();
my $TERM = $ENV{TERM};

my %SUPPORTED_SHELLS = map { ($_ => undef) } qw(bash zsh);

GetOptions(
    shell => \$SHELL,
);


unless ($SHELL) {
    $SHELL = $ENV{SHELL};
    $SHELL =~ s{^.*/}{};
} else {
    $SHELL =~ s/^-//;
}

my $FIFO_PATH = tmpnam().".$$";
my $FIFO_IN = "$FIFO_PATH.in";
my $FIFO_OUT = "$FIFO_PATH.out";

if (-t STDOUT) {
    print "TODO: diagnostics output\n";
    print "$FIFO_IN\n";
    print "$FIFO_OUT\n";
    print "SHELL=$SHELL\n";
    print STDERR "usage: eval `angel-prompt --shell=\$0`\n";
    exit 1;
}

# *****************************************************************************
# Angel startup
# *****************************************************************************
mkfifo($FIFO_IN, 0600) or die "Can't create fifo $FIFO_IN: $!";
mkfifo($FIFO_OUT, 0600) or die "Can't create fifo $FIFO_OUT: $!";

# The shell code will be evaluated with eval as a single line
# so statements must be properly terminated with ';'
# No shell comments allowed
print <<EOF;
[[ -n "\$APS1_PID" ]] && angel leave;
APS1_PS1="\$PS1";
APS1_PROMPT_COMMAND="\$PROMPT_COMMAND";
angel-PS1()
{
    local err=\$?;
    [[ -e '$FIFO_IN' ]] || { angel leave ; return ; };
    echo -nE "\$err a=b PWD=\$PWD" > '$FIFO_IN' || { angel leave ; return ; };
    read PS1 < '$FIFO_OUT' || angel leave ;
    printf 'DEBUG> PS1=%q\\n' "\$PS1" ;
} ;
PROMPT_COMMAND=angel-PS1 ;
angel()
{
    case "\$1" in
    leave)
        PROMPT_COMMAND="\$APS1_PROMPT_COMMAND" ;
        PS1="\$APS1_PS1" ;
        kill \$APS1_PID 2>/dev/null ;
        rm -f -- '$FIFO_IN' '$FIFO_OUT' ;
        unset APS1_PS1 APS1_PID ;
        unset -f angel angel-PS1 ;;
    *)
        echo 'What?' >&2 ;
        return 1 ;;
    esac ;
} ;
EOF
# TODO: exit trap to kill the daemon

close STDIN;

my $child = fork();
die if $child == -1;
if ($child) {
    # We don't want the fifos to be removed by the END block
    undef $FIFO_IN;
    undef $FIFO_OUT;
    print "APS1_PID=$child\n";
    print STDERR "angel-prompt $child installed.\n";
    exit 0;
}

# *****************************************************************************
# Angel forked
# *****************************************************************************

open STDIN, '+<', '/dev/null';
close STDOUT;
open STDOUT, '>', '/dev/null';


# Ignore ^C sent to the terminal
$SIG{INT} = sub {
    print STDERR "Ctrl+C !\n";
    #exit 0;
};
# Clean exits that will call our END block
$SIG{HUP} = $SIG{TERM} = sub { exit 0 };


# *****************************************************************************
# Angel main loop
# *****************************************************************************
    for (;;) {
        my $FIFO;
        unless (open $FIFO, '<', $FIFO_IN) {
            redo if -e $FIFO_IN && -p _;
            last;
        }
        $_ = do { undef $/; <$FIFO> };
        close $FIFO;
        print STDERR "DEBUG< [$_]\n";

        # FIXME handle $PWD with '\n'
        my ($err, $opts, $PWD) = /^(\d+) (.*?) PWD=(.*)$/;
        # FIXME rewrite parsing to support quoting
        my %opt;
        %opt = map { ( m/^(.*?)=(.*)/ ) } split / /, $opts if defined $opts;

        my $PS1 = (scalar localtime) . " $err \\w\\\$ ";

        open $FIFO, '>', $FIFO_OUT;
        # Escape the last space using bash PS1 encoding as 'read' removes spaces
        # at beginning and end of line
        (my $out = $PS1) =~ s/^ | $/\\040/g;
        # Escape \ as 'read' expands them
        $out =~ s/\\/\\\\/g;
        # Escape newlines
        $out =~ s/\n/\\\n/g;
        print $FIFO "$out\n";
        close $FIFO;
    }


END {
    no warnings 'uninitialized';
    unlink $FIFO_IN, $FIFO_OUT;
}

# vim:set et ts=8 sw=4 sts=4:
