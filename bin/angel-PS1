#!/usr/bin/perl
use utf8;

#    Copyright © 2013 Olivier Mengué
#    Original source code is available at https://github.com/dolmen/angel-PS1
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.



use 5.008003;  # 5.010 is the sane minimum
use strict;
use warnings;

package AngelPS1;

our $VERSION = '0.0';

use Getopt::Long qw(:config posix_default no_ignore_case auto_help);
use File::Temp 'tmpnam';
use Encode ();
use FindBin;
use IPC::Open3 ();
use Symbol 'gensym';

use lib "$ENV{HOME}/.config/angel-PS1", '/etc/angel-PS1';


# Extact encoding name from the locale
our $ENCODING = do {
    # Shortcut for the most common case
    my $locale = $ENV{LC_ALL} || $ENV{LC_CTYPE} || $ENV{LANG} || 'POSIX';
    $locale =~ /\.UTF-?8(?:@.*)?$/i
        ? 'UTF-8'
        : do {
            # warn "slow locale lookup...";
            require POSIX;
            POSIX::setlocale(POSIX::LC_CTYPE(), '');
            require I18N::Langinfo;
            eval { I18N::Langinfo::langinfo(I18N::Langinfo::CODESET()) }
                or do { warn $@; undef }
        }
};

# Decode @ARGV and encode STDOUT, STDERR
if ($ENCODING) {
    my $encoding_obj = Encode::find_encoding($ENCODING);
    map { $_ = $encoding_obj->decode($_) } @ARGV;
    binmode(STDOUT, ":encoding($ENCODING)");
    binmode(STDERR, ":encoding($ENCODING)");
}

our $APP = !defined scalar caller;  # Running as command or include
$main::VERSION = $VERSION if $APP;
our $DEBUG = !! $ENV{APS1_DEBUG};
our $SHELL;
our $NAME = 'angel';
our $VERBOSE = 0;
our $SHELL_PID = getppid();
our $TERM = $ENV{TERM};

my %SUPPORTED_SHELLS = map { ($_ => undef) } qw(bash zsh);

{
    my @PATH = split /:/, $ENV{'PATH'};
    my %which;

    sub which ($)
    {
        my ($name, $no_cache) = @_;

        # Use the cache
        return $which{$name} if exists $which{$name};
        # Already a path with a directory?
        return $name if index($name, '/') >= 0;

        # Search in $PATH
        foreach my $p (@PATH) {
            my $f = "$p/$name";
            if (-x $f && ! -d _) {
                $which{$name} = $f unless $no_cache;
                return $f;
            }
        }
        undef
    }
}

sub run
{
    my $command = which(shift);
    my ($in, $out);
    my $err = gensym;
    my $pid = IPC::Open3::open3(
        $in,
        $out,
        $err,
        $command,
        @_
    );
    my $result = do { undef $/; readline $out };
    # TODO UTF-8 decoding
    waitpid($pid, 0);
    return $result
}

sub one_line
{
    # chop
    (my $result = shift) =~ s{\n$}{}s;
    $result
}

sub terminfo ($;@); # Pre-declare for recursion

my %terminfo_cache;

sub terminfo ($;@)
{
    my ($capability, @args) = @_;
    if (ref $capability) {
        my $cap0 = $capability->[0];
        if (exists $terminfo_cache{"\0$cap0"}) {
            $capability = $terminfo_cache{"\0$cap0"}
        } else {
            for my $cap (@$capability) {
                my $res = terminfo $cap, @args;
                next if $res eq '';
                $terminfo_cache{"\0$cap0"} = $cap if $cap ne $cap0;
                return $res
            }
            return '';
        }
    }

    my $query = join("\0", $capability, @args);
    return $terminfo_cache{$query} if exists $terminfo_cache{$query};

    my $result = run(tput => $capability, @args);

    # Cache the result
    $terminfo_cache{$query} = $result;

    $result
}

sub setaf ($) { terminfo [ qw(setaf AF) ], $_[0] }

my ($BLACK, $RED, $GREEN, $YELLOW, $BLUE, $MAGENTA, $CYAN, $GRAY) =
    map { setaf $_ } 0..7;
my $BOLD = terminfo [ qw(bold md) ];
my $NO_COLOR = terminfo [ qw(sgr0 me) ];
my ($B, $E) = ('\[', '\]');

$SIG{__DIE__} = sub {
    return if $^S;
    if (-t STDERR) {
        my $last = pop @_;
        $last =~ s/(\n)$//s;
        die "$RED$FindBin::Script: ", @_, $last, $NO_COLOR, ($1 ? ($1) : ());
    } else {
        die "$FindBin::Script: ", @_;
    }
};

if (-t STDERR) {
    $SIG{__WARN__} = sub {
        my $last = pop;
        $last =~ s/(\n)$//s;
        warn "$YELLOW$BOLD", @_, $last, $NO_COLOR, ($1 ? ($1) : ());
    };
}

sub interp
{
    my $state = shift;
    my @args = @_;
    for(my $i=0; $i<=$#args; $i++) {
        if (ref($args[$i]) eq 'CODE') {
            splice @args, $i, 1, interp($state, $args[$i]->($state));
            redo;
        }
    }
    return @args
}

# Compact a @PS1 definition: scalar refs are expanded to their escaped result
# and static strings are then concatenated.
sub compact
{
    my @template = @_;
    my @out;
    while (@template) {
        my $v = shift @template;
        my $r = ref $v;
        # Reference followed by a scalar => replace by the expanded result
        if ($r eq 'SCALAR' && @template && !ref $template[0]) {
            $v = expand($v, shift @template);
            $r = ref $v;
        }
        if (!$r && (@out >= 1 && !ref($out[$#out]))
                && (@out == 1 || !ref($out[$#out-1]))) {
            $out[$#out] .= $v
        } else {
            push @out, $v
        }
    }
    @out
}

sub expand
{
    my @args = @_;
    my $out = '';
    my $color;
    while (@args) {
        my $v = shift @args;
        my $r = ref $v;
        if ($r eq 'SCALAR') {
            # TODO also handle strings that don't start with \e as margins
            $color = $$v;
            $out .= $B . $color . $E;
        } else {
            $out .= $v;
            if (defined $color) {
                $out .= $B . $NO_COLOR . $E;
                undef $color;
            }
        }
    }
    return $out
}

my @INCLUDES;

GetOptions(
    'shell=s' => \$SHELL,
    'name=s' => \$NAME,
    'v|verbose' => \$VERBOSE,
    'q|quiet' => sub { $VERBOSE = -1 },
    'debug'  => \$DEBUG,
    'I=s' => \@INCLUDES,
);

# Order is important: preserve the order as perl itself
lib->import(@INCLUDES);
undef @INCLUDES;

unless ($SHELL) {
    # Extract the name of $PPID
    $SHELL = one_line(run(ps => qw(-o comm=), $SHELL_PID));
}

# The angel name must be a valid shell function identifier
# Note that '-' is allowed, even as a first char
$NAME =~ /^[-A-Z_][-A-Z_0-9]*$/si or die "invalid angel name";

{
# The public API for plugins
package AngelPS1::Plugin;
use Exporter 5.57 'import';
BEGIN {
    $INC{'AngelPS1/Plugin.pm'} = __FILE__;
    our $VERSION = $AngelPS1::VERSION;
    our @EXPORT = qw(compact interp);
    *compact = \&AngelPS1::compact;
    *interp = \&AngelPS1::interp;
}

package AngelPS1::Plugin::Core;

use Exporter 5.57 'import';
BEGIN {
    our $VERSION = $AngelPS1::VERSION;
    our @EXPORT = qw(Escape MarginLeft);
}

use AngelPS1::Plugin;

sub Escape
{
    my @content = compact(@_);
    sub {
        my @result = interp @content;
        \ compact(@result);
    }
}

sub MarginLeft
{
    my $code = pop;
    my $margin = shift;
    $margin = ' ' unless defined $margin;
    sub {
        my @result = interp $code;
        return unless @result;
        ($margin, @result)
    }
}

package AngelPS1::Plugin::TerminalSize;

#use Exporter 5.57 ();

our ($LINES, $COLUMNS);

my $_WINSZ;
BEGIN {
    our $VERSION = $AngelPS1::VERSION;
    our @ISA = 'Exporter';
    our @EXPORT = qw($LINES $COLUMNS);
    $_WINSZ = pack('S4');
}

sub _update_winsize
{
    ioctl(STDERR, &TIOCGWINSZ, $_WINSZ);
    ($LINES, $COLUMNS) = unpack('S2', $_WINSZ);
}


sub import
{
    # Avoid multiple install due to multiple import from different packages
    unless (defined $SIG{WINCH}) {
        # Delay loading of ioctl.ph until import time
        no strict 'refs';
        *TIOCGWINSZ = do {
            package AngelPS1::Plugin::TerminalSize::ioctl;
            require 'sys/ioctl.ph';
            \&TIOCGWINSZ
        };
        delete $INC{'sys/ioctl.ph'};
        # Terminal size change
        $SIG{WINCH} = \&_update_winsize;

        # Fetch now
        _update_winsize;
    }

    $_[0]->export_to_level(1, @_);
}


package AngelPS1::Plugin::Git;

use Exporter 5.57 'import';
BEGIN {
    our $VERSION = $AngelPS1::VERSION;
    our @EXPORT = qw(GitInfo);
}

my $git = AngelPS1::which 'git';
sub git
{
    # All Git commands we call return a single line. We don't want '\n'
    AngelPS1::one_line(AngelPS1::run $git, @_)
}

sub GitInfo
{
    my $shell_state = shift;

    my $git_dir = "$shell_state->{'PWD'}/.git";
    unless (-d $git_dir) {
        ($git_dir = git qw(rev-parse --git-dir))
            or return;
    }
    local $ENV{'GIT_DIR'} = $git_dir;

    my @out;
    my $local_commits = 0;

    my $branch = git 'symbolic-ref', 'HEAD';
    if ($branch eq '') {
        ($branch = git 'rev-parse', '--short')
            or return;
    } else {
        $branch =~ s{^refs/heads/}{};

        # Count the number of commits to push ($local_commits)
        if ((my $remote_branch = git qw(config --get), "branch.$branch.merge")
            && (my $remote = git qw(config --get), "branch.$branch.remote")) {

            # Compute the ref of our local image of the remote branch
            (my $remote_branch_ref = $remote_branch) =~ s{^refs/heads/}{refs/remotes/$remote/};

            # Count the commits
            $local_commits =
                git(qw(rev-list --no-merges --count),
                    "$remote_branch_ref..HEAD")
                || 0;
        }
    }

    my $status = git qw(status --porcelain -z);
    my $untracked = $status =~ /(?:^|\0)\?\? /s;

    if (my $shortstat = git qw(diff --shortstat)) {
        my ($ins) = ($shortstat =~ /([0-9]+) insertions?\(/);
        my ($del) = ($shortstat =~ /([0-9]+) deletions?\(/);

        push @out,
            \$RED, $branch, \$NO_COLOR,
            '(',
                \$MAGENTA,
                ($ins ? ("+$ins" . ($del ? "/" : '')) : '') . ($del ? "-$del" : ''),
                ($local_commits ? (\$NO_COLOR, ',', \$YELLOW, $local_commits) : ()),
                \$NO_COLOR,
            ')';
    } elsif ($local_commits) {
        push @out,
            \$YELLOW, $branch, \$NO_COLOR,
            '(', \$YELLOW, $local_commits, \$NO_COLOR, ')';
    } else {
        push @out, \$GREEN, $branch, \$NO_COLOR;
    }

    if (-f "$git_dir/refs/stash") {
        push @out, \$RED, '+', \$NO_COLOR;
    }

    if ($untracked) {
        push @out, \$RED, '*', \$NO_COLOR;
    }

    # TODO Git mark

    @out, ' '
}

} # End of embedded packages




# Load the configuration from @INC
# Usually: $HOME/.config/angel-PS1/PS1.pl
my @PS1 = do { package AngelPS1::Config; do 'PS1.pl' };
die "Invalid configuration: $@" if $@;
pop @PS1 if @PS1 == 1 && !defined $PS1[0];


# TODO load the default PS1 in the AngelPS1::Config namespace
BEGIN {
    AngelPS1::Plugin::Core->import;
    AngelPS1::Plugin::TerminalSize->import;
    AngelPS1::Plugin::Git->import;
}

unless (@PS1) {
    require POSIX;
    (my $TTYNAME = POSIX::ttyname(0)) =~ s{^/dev/}{};

    @PS1 =
    (
        \$BLUE,
        sub { sprintf('%3$02d:%2$02d:%1$02d', localtime) },
        ' ',
        $TTYNAME,
        (sub { "(${COLUMNS}x${LINES})" }) x!! $DEBUG,
        ' ',
        sub { -w $_[0]->{PWD} ? (\$GREEN) : (\$RED) },
        ':',
        '\\w',
        ' ',
        \&GitInfo,
        sub { my $err = $_[0]->{'?'}; $err == 0 ? () : (\$RED, $err, ' ') },
        # User mark: root => #    else  $
        ($< ? (\$BOLD, '\\$') : (\"$BOLD$RED", '#')),
        ' ',
    );
}


@PS1 = compact @PS1;



my $FIFO_PATH = tmpnam().".$NAME-$$";
my $FIFO_IN = "$FIFO_PATH.in";
my $FIFO_OUT = "$FIFO_PATH.out";

if (-t STDOUT) {
    die "TERM is not set\n" unless exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

    unless ($ENCODING) {
        warn "Encoding not set in locale. Please set LC_CTYPE.\n";
    } elsif ($ENCODING !~ /^UTF-/i) {
        # Get the canonical name
        $ENCODING = Encode::find_encoding($ENCODING)->name;
        warn "Your locale is not set to a known Unicode encoding (such as 'UTF-8') but to '$ENCODING'. Please report your use case to the Angel PS1 developers.\n"
    }

    #print "${RED}Red!${NO_COLOR}\n";

    print "Copyright (C) 2013  Olivier Mengué\n",
          "This program comes with ABSOLUTELY NO WARRANTY;\n",
          "This is free software, and you are welcome to redistribute it\n",
          "under certain conditions;\n",
          "See \"sed -n '4,19{s/.//;p}' \$(which $0)\" for details.\n\n";
    print STDERR "usage: eval `$FindBin::Script`\n";

    #print 'Running as an app: ', $APP, "\n";
    #print "\$Bin: $FindBin::Bin\n";
    #print "\$Script: $FindBin::Script\n";
    #print '__FILE__: ', __FILE__, "\n";
    #print "\%INC:\n  - ", join("\n  - ", sort keys %INC), "\n";
    #print "\@INC:\n  - ", join("\n  - ", @INC), "\n";

    exit 1;
}

# *****************************************************************************
# Angel startup
# *****************************************************************************

# No terminal? This is not an interactive shell.
# So we don't install.
exit 0 unless -t STDIN && exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

$SHELL eq 'bash' or die "Your shell ($SHELL) is not (yet?) supported.\n";

# If the prompt is static after compact(), just output it and don't install the
# angel. This allows the user to use the power of the angel-PS1 prompt compiler
# and plugins without the runtime cost.
if (@PS1 == 1) {
    (my $PS1 = $PS1[0]) =~ s/'/'\\''/g;
    print qq{[[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave; PS1='$PS1'\n};
    exit 0
}


require POSIX;
POSIX::mkfifo($FIFO_IN, 0600) or die "Can't create fifo $FIFO_IN: $!";
POSIX::mkfifo($FIFO_OUT, 0600) or die "Can't create fifo $FIFO_OUT: $!";
-p $FIFO_IN && -o _ or die "Fifo $FIFO_IN creation failed.";
-p $FIFO_OUT && -o _ or die "Fifo $FIFO_OUT creation failed.";

# The shell code will be evaluated with eval as a single line
# so statements must be properly terminated with ';'
# No shell comments allowed
my $shell_debug = $DEBUG ? q|printf 'DEBUG> PS1=%q\\n' "$PS1" ; | : '';
print <<EOF;
[[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave;
APS1_PS1="\$PS1";
APS1_PROMPT_COMMAND="\$PROMPT_COMMAND";
-angel-PS1()
{
    local err=\$?;
    [[ -e '$FIFO_IN' ]] || { $NAME leave ; return ; };
    printf '%s\\0%s' "?=\$err" "PWD=\$PWD" > '$FIFO_IN' || { $NAME leave ; return ; };
    read PS1 < '$FIFO_OUT' || $NAME leave ;
    $shell_debug
} ;
PROMPT_COMMAND=-angel-PS1 ;
APS1_NAME=$NAME ;
$NAME()
{
    case "\$1" in
    leave|quit|go-away)
        PROMPT_COMMAND="\$APS1_PROMPT_COMMAND" ;
        PS1="\$APS1_PS1" ;
        kill \$APS1_PID 2>/dev/null ;
        rm -f -- '$FIFO_IN' '$FIFO_OUT' ;
        unset APS1_PS1 APS1_PID APS1_NAME ;
        unset -f -- $NAME -angel-PS1 ;;
    mute|off)
        PROMPT_COMMAND="\$APS1_PROMPT_COMMAND" ;
        PS1="\$APS1_PS1" ;;
    unmute|on)
        PROMPT_COMMAND=angel-PS1 ;;
    *)
        echo 'What?' >&2 ;
        return 1 ;;
    esac ;
} ;
EOF
# TODO: exit trap to kill the daemon

close STDIN;

my $child = fork();
die if $child == -1;
if ($child) {
    # We don't want the fifos to be removed by the END block
    undef $FIFO_IN;
    undef $FIFO_OUT;
    print "APS1_PID=$child\n";
    print STDERR "$NAME installed.\n" unless $VERBOSE < 0;
    exit 0;
}

# *****************************************************************************
# Angel forked
# *****************************************************************************

open STDIN, '+<', '/dev/null';
close STDOUT;
open STDOUT, '>', '/dev/null';


# Ignore ^C sent to the terminal
$SIG{INT} = sub {
    print STDERR "Ctrl+C !\n";
    #exit 0;
};
# Clean exits that will call our END block
$SIG{HUP} = $SIG{TERM} = sub { exit 0 };





# *****************************************************************************
# Angel main loop
# *****************************************************************************
sub main_loop
{
    my @PS1 = @_;

    my $FIFO;
    for (;;) {
        unless (open $FIFO, "<:encoding($ENCODING)", $FIFO_IN) {
            redo if -e $FIFO_IN && -p _;
            last;
        }
        $_ = do { undef $/; <$FIFO> };
        close $FIFO;
        printf STDERR "DEBUG< %s\n", do { (my $tmp = $_) =~ s/\0/ /g; $tmp } if $DEBUG;

        my %shell_state = map { ( m/^(.*?)=(.*)/s ) } split /\0/;

        chdir $shell_state{'PWD'};

        my $PS1 = expand(interp(\%shell_state, @PS1));

        open $FIFO, ">:encoding($ENCODING)", $FIFO_OUT;
        # Escape the last space using bash PS1 encoding as 'read' removes spaces
        # at beginning and end of line
        (my $out = $PS1) =~ s/^ | $/\\040/g;
        # Escape \ as 'read' expands them
        $out =~ s/\\/\\\\/g;
        # Escape newlines
        $out =~ s/\n/\\\n/g;
        print $FIFO "$out\n";
        close $FIFO;
    }
}

main_loop(@PS1);

END {
    no warnings 'uninitialized';
    unlink $FIFO_IN, $FIFO_OUT;
}

# vim:set et ts=8 sw=4 sts=4:
