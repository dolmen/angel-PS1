#!/usr/bin/perl
use utf8;

#    Copyright © 2013 Olivier Mengué
#    Original source code is available at https://github.com/dolmen/angel-PS1
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.



use 5.008003;  # 5.010 is the sane minimum
use strict;
use warnings;

package AngelPS1;

our $VERSION = '0.03';

use Getopt::Long qw(:config posix_default no_ignore_case auto_help);
use POSIX ();
use Encode ();
use FindBin;

# TODO build.pl should inline those modules
use AngelPS1::Shell ();
use AngelPS1::Compiler;
use AngelPS1::Color;

use lib "$ENV{HOME}/.config/angel-PS1", '/etc/angel-PS1';


# Extract encoding name from the locale
our $ENCODING = do {
    # Shortcut for the most common case
    my $locale = $ENV{LC_ALL} || $ENV{LC_CTYPE} || $ENV{LANG} || 'POSIX';
    $locale =~ /\.UTF-?8(?:@.*)?$/i
        ? 'UTF-8'
        : do {
            # warn "slow locale lookup...";
            POSIX::setlocale(POSIX::LC_CTYPE(), '');
            require I18N::Langinfo;
            eval { I18N::Langinfo::langinfo(I18N::Langinfo::CODESET()) }
                or do { warn $@; undef }
        }
};

# Decode @ARGV and encode STDOUT, STDERR
if ($ENCODING) {
    my $encoding_obj = Encode::find_encoding($ENCODING);
    map { $_ = $encoding_obj->decode($_) } @ARGV;
    binmode(STDOUT, ":encoding($ENCODING)");
    binmode(STDERR, ":encoding($ENCODING)");
}

our $APP = !defined scalar caller;  # Running as command or include
$main::VERSION = $VERSION if $APP;

our %DEBUG;
# Initialize from $ENV{APS1_DEBUG}
BEGIN {
    my @DEBUG_DEFAULTS = qw< in time >;

    sub _DEBUG
    {
        # $value is in $_[1] (instead of $_[0]) to be compatible with GetOptions
        # callback
        my $value = $_[1];
        if ($value eq '' || $value eq '1') {
            $DEBUG{$_} = 1 for @DEBUG_DEFAULTS
        } else {
            my @debug = split /,/, $value;
            splice(@debug, 0, 1, @DEBUG_DEFAULTS) if $debug[0] eq '';
            $DEBUG{$_} = 1 for @debug
        }
    }

    _DEBUG(undef, $ENV{APS1_DEBUG})
        if defined $ENV{APS1_DEBUG} && length $ENV{APS1_DEBUG};
}

our $SHELL;
our $NAME = 'angel';
our $VERBOSE = 0;
our $SHELL_PID = getppid();
our $TERM = $ENV{TERM};
my ($CONFIG, $PROMPT);
my $RUN_TEST;



$SIG{__DIE__} = sub {
    return if $^S;
    if (-t STDERR) {
        my $last = pop @_;
        $last =~ s/(\n)$//s;
        die "$RED$FindBin::Script: ", @_, $last, $NO_COLOR, ($1 ? ($1) : ());
    } else {
        die "$FindBin::Script: ", @_;
    }
};

if (-t STDERR) {
    $SIG{__WARN__} = sub {
        my $last = pop;
        $last =~ s/(\n)$//s;
        warn "$YELLOW$BOLD", @_, $last, $NO_COLOR, ($1 ? ($1) : ());
    };
}



my @INCLUDES;

GetOptions(
    'version' => sub { print "angel-PS1 version $VERSION\n"; exit 0 },
    'test'    => \$RUN_TEST,
    'shell=s' => \$SHELL,
    'name=s' => \$NAME,
    'c|config=s' => \$CONFIG,
    'p|prompt=s' => \$PROMPT,
    'v|verbose' => \$VERBOSE,
    'q|quiet' => sub { $VERBOSE = -1 },
    'debug:s'  => \&_DEBUG,
    'I=s' => \@INCLUDES,
);

# Order is important: preserve the order as perl itself
lib->import(@INCLUDES);
undef @INCLUDES;

unless ($SHELL) {
    require AngelPS1::Util;
    # Extract the name of $PPID
    my $comm_file = "/proc/$SHELL_PID/comm";
    if (-f $comm_file && -r _) { # Linux shortcut
        open my $comm, '<', $comm_file;
        $SHELL = <$comm>
    } else {
        $SHELL = AngelPS1::Util::run(ps => qw(-o comm=), $SHELL_PID)
    }
    $SHELL = AngelPS1::Util::one_line($SHELL);
}

# Dynamically load our shell plugin
AngelPS1::Shell->use($SHELL);

# The angel name must be a valid shell function identifier
# Note that '-' is allowed, even as a first char
$NAME =~ /^[-A-Z_][-A-Z_0-9]*$/si or die "invalid angel name";



my @PS1;

# Load the configuration from @INC
{
    my @configs;

    if (defined $PROMPT) {
        (my $mod = "AngelPS1/Prompt/$PROMPT.pm") =~ s{::}{/};
        push @configs, $mod, "$PROMPT.PS1";
    } elsif ($CONFIG) {
        push @configs, $CONFIG;
    } else {
        # Usually: $HOME/.config/angel-PS1/angel.PS1
        push @configs, "AngelPS1/Prompt/$NAME.pm", "$NAME.PS1", 'AngelPS1/Prompt/Default.pm';
    }

    undef $CONFIG;
    foreach my $config (@configs) {
        undef $!;
        @PS1 = do { package AngelPS1::Prompt; do $config };
        die "load error: $@" if $@;
        unless ($!) {
            # Break if loading is ok
            $CONFIG = ref($INC{$config}) ? $config : $INC{$config};
            last;
        }
        warn "$config load error: $!" if $! && $DEBUG{config};
        $CONFIG = $config;
    }
    die "$CONFIG load error: $!" if $!;
}

die "invalid prompt value returned by $CONFIG: empty list\n" unless @PS1;
die "invalid prompt value returned by $CONFIG: undef value\n" unless defined $PS1[0];

print STDERR "${NAME}'s config: $CONFIG\n" if $DEBUG{config};


@PS1 = reduce @PS1;


# Build the FIFO paths
my $FIFO_PATH = POSIX::tmpnam().".$NAME-$$";
my $FIFO_IN = "$FIFO_PATH.in";
my $FIFO_OUT = "$FIFO_PATH.out";

if ($RUN_TEST || -t STDOUT) {
    die "TERM is not set\n" unless exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

    unless ($ENCODING) {
        warn "Encoding not set in locale. Please set LC_CTYPE.\n";
    } elsif ($ENCODING !~ /^UTF-/i) {
        # Get the canonical name
        $ENCODING = Encode::find_encoding($ENCODING)->name;
        warn "Your locale is not set to a known Unicode encoding (such as 'UTF-8') but to '$ENCODING'. Please report your use case to the Angel PS1 developers.\n"
    }

    if ($RUN_TEST) {
        reduce(expand({ '?' => 0, PWD => $ENV{PWD} }, @PS1));
        exit 0;
    }

    #print "${RED}Red!${NO_COLOR}\n";

    print "angel-PS1 $VERSION\n";

    my $script = index($0, '/') >= 0 ? $0 : "\$(which $FindBin::Script)";
    print "Copyright (C) 2013  Olivier Mengué\n",
          "This program comes with ABSOLUTELY NO WARRANTY;\n",
          "This is free software, and you are welcome to redistribute it\n",
          "under certain conditions;\n",
          "Run \"sed -n '2,19{s/.//;p}' $script | iconv -f UTF-8\" for details.\n\n";
    print STDERR "usage: eval `$0`\n";

    #print 'Running as an app: ', $APP, "\n";
    #print "\$Bin: $FindBin::Bin\n";
    #print "\$Script: $FindBin::Script\n";
    #print '__FILE__: ', __FILE__, "\n";
    #print "\%INC:\n  - ", join("\n  - ", sort keys %INC), "\n";
    #print "\@INC:\n  - ", join("\n  - ", @INC), "\n";

    exit 1;
}

# *****************************************************************************
# Angel startup
# *****************************************************************************

# No terminal? This is not an interactive shell.
# So we don't install.
exit 0 unless -t STDIN && exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

# If the prompt is static after reduce(), just output it and don't install the
# angel. This allows the user to use the power of the angel-PS1 prompt compiler
# and plugins without the runtime cost.
if (ps1_is_static(\@PS1)
    and my $shell_code_static = AngelPS1::Shell->can('shell_code_static')) {

    (my $PS1 = ${$PS1[0]}) =~ s/'/'\\''/g;

    print AngelPS1::Shell->$shell_code_static(
        $PS1,
        name  => $NAME,
        debug => \%DEBUG,
    );

    exit 0
}


POSIX::mkfifo($FIFO_IN, 0600) or die "Can't create fifo $FIFO_IN: $!";
POSIX::mkfifo($FIFO_OUT, 0600) or die "Can't create fifo $FIFO_OUT: $!";
-p $FIFO_IN && -o _ or die "Fifo $FIFO_IN creation failed.";
-p $FIFO_OUT && -o _ or die "Fifo $FIFO_OUT creation failed.";

my $child = fork();
die if $child == -1;
if ($child) {
    print AngelPS1::Shell->shell_code_dynamic(
        name  => $NAME,
        debug => \%DEBUG,
        in    => $FIFO_IN,
        out   => $FIFO_OUT,
        env   => [qw< PWD >],
        pid   => $child,
    );

    print STDERR "$NAME installed.\n" unless $VERBOSE < 0;

    # We don't want the fifos to be removed by the END block
    undef $FIFO_IN;
    undef $FIFO_OUT;

    exit 0;
}

# *****************************************************************************
# Angel forked
# *****************************************************************************

$0 = qq{$FindBin::Script $NAME};

open STDIN, '+<', '/dev/null';
close STDOUT;
open STDOUT, '>', '/dev/null';


# Ignore ^C sent to the terminal
$SIG{INT} = sub {
    print STDERR "Ctrl+C !\n";
    #exit 0;
};
# Clean exits that will call our END block
$SIG{HUP} = $SIG{TERM} = sub { exit 0 };



# PS1 fallback, if something goes wrong with the user defined prompt
my $PS1_fallback = do {
    my @fallback = reduce(
        "[$NAME sick!] ",
        AngelPS1::Shell->WorkingDir,
        AngelPS1::Shell->UserPrivSymbol,
        ' ',
    );

        ps1_is_static(\@fallback)
    ? do { my $fallback = ${$fallback[0]}; sub { $fallback } }
    : sub { scalar reduce(expand(@_, @fallback)) }
};


# *****************************************************************************
# Angel main loop
# *****************************************************************************
sub main_loop
{
    my @PS1 = @_;

    my $FIFO;
    my %prompt_state;
    my ($k, $v);

    for (;;) {
        unless (open $FIFO, "<:encoding($ENCODING)", $FIFO_IN) {
            redo if -e $FIFO_IN && -p _;
            last;
        }
        $_ = do { undef $/; <$FIFO> };
        close $FIFO;
        printf STDERR "DEBUG< %s\n", do { (my $tmp = $_) =~ s/\0/ /g; $tmp } if $DEBUG{'in'};

        #my @shell_keys;
        foreach (split /\0/) {
            ($k, $v) = m/^(.*?)=(.*)/s;
            #push @shell_keys, $k;
            $prompt_state{$k} = $v;
        }

        chdir $prompt_state{'PWD'};

        my $PS1 = eval { reduce(expand(\%prompt_state, @PS1)) };
        unless (defined $PS1) {
            (my $err = $@) =~ s/\s*$//s;
            print STDERR "$RED$BOLD$NAME PS1 eval: $err$NO_COLOR\n";
            $PS1 = $PS1_fallback->(\%prompt_state);
        }

        open $FIFO, ">:encoding($ENCODING)", $FIFO_OUT;
        print $FIFO AngelPS1::Shell->ps1_finalize($PS1);
        close $FIFO;

        # Cleanup for next iteration, but so far the keys of shell_state
        # are always the same
        #delete @prompt_state{@shell_keys};
    }
}

main_loop(@PS1);

END {
    no warnings 'uninitialized';
    unlink $FIFO_IN, $FIFO_OUT;
}

__END__

=encoding utf-8

=head1 NAME

angel-PS1 - The Angel's Prompt

=head1 SYNOPSIS

Install a prompt (bash/mksh/dash):

    eval `angel-PS1 [--name <name>] [-I <dir>] [-p <prompt> | -c <config>]`

Install a prompt (fish):

    eval (angel-PS1 [--name <name>] [-I <dir>] [-p <prompt> | -c <config>])

Test a prompt definition:

    angel-PS1 [--name <name>] [-I <dir>] [-p <prompt> | -c <config>]
              [--shell <shell>] --test

=head1 CONFIGURATION

The default prompt definition comes from C<AngelPS1::Prompt::Default> that is
embeded in C<angel-PS1>.

You can use your own prompt definition defined in a file.

The prompt definition is searched as a file in perl's standard C<@INC> to which
F<$HOME/.config/angel-PS1> and F</etc/angel-PS1> have been preprended. See
option C<-I> to prepend more paths.

The following settings are used to determine the path/name of the file relative
to an C<@INC> directory (I<C<$ANGEL>> is the name of the angel (see the
C<--name> option, C<angel> is the default):

=over 4

=item *

if I<C<$PROMPT>> is set with the C<--prompt> option:

=over 4

=item -

the C<AngelPS1::Prompt::I<$PROMPT>> perl module:
F<AngelPS1/Prompt/I<$PROMPT>.pm>

=item -

the F<I<$PROMPT>.PS1> file

=back

=item *

if C<--config I<$CONFIG>> option is given, the F<I<$CONFIG>> file

=item *

the C<AngelPS1::Prompt::I<$NAME>> perl module:
F<AngelPS1/Prompt/I<$NAME>.pm>

=item *

the F<I<$NAME>.PS1> file

=back

=head1 SHELLS

angel-PS1 is compatible with:

=over 4

=item *

bash

=item *

mksh

=item *

dash

=item *

fish

=back

=head1 SUPPORT

Bug tracker: L<https://github.com/dolmen/angel-PS1/issues>

Announces of new releases: L<https://twitter.com/nglPS1>

=head1 AUTHOR

Olivier Mengué, L<mailto:dolmen@cpan.org>

=head1 COPYRIGHT & LICENSE

See the header of this file.

=cut

# vim:set et ts=8 sw=4 sts=4:
