#!/usr/bin/perl
use utf8;

#    Copyright © 2013 Olivier Mengué
#    Original source code is available at https://github.com/dolmen/angel-PS1
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.



use 5.008003;  # 5.010 is the sane minimum
use strict;
use warnings;

package AngelPS1;

our $VERSION = '0.02';

use Getopt::Long qw(:config posix_default no_ignore_case auto_help);
use File::Temp 'tmpnam';
use Encode ();
use FindBin;

# TODO build.pl should inline those modules
use AngelPS1::Shell ();
use AngelPS1::Color;

use lib "$ENV{HOME}/.config/angel-PS1", '/etc/angel-PS1';


# Extact encoding name from the locale
our $ENCODING = do {
    # Shortcut for the most common case
    my $locale = $ENV{LC_ALL} || $ENV{LC_CTYPE} || $ENV{LANG} || 'POSIX';
    $locale =~ /\.UTF-?8(?:@.*)?$/i
        ? 'UTF-8'
        : do {
            # warn "slow locale lookup...";
            require POSIX;
            POSIX::setlocale(POSIX::LC_CTYPE(), '');
            require I18N::Langinfo;
            eval { I18N::Langinfo::langinfo(I18N::Langinfo::CODESET()) }
                or do { warn $@; undef }
        }
};

# Decode @ARGV and encode STDOUT, STDERR
if ($ENCODING) {
    my $encoding_obj = Encode::find_encoding($ENCODING);
    map { $_ = $encoding_obj->decode($_) } @ARGV;
    binmode(STDOUT, ":encoding($ENCODING)");
    binmode(STDERR, ":encoding($ENCODING)");
}

our $APP = !defined scalar caller;  # Running as command or include
$main::VERSION = $VERSION if $APP;
our $DEBUG = !! $ENV{APS1_DEBUG};
our $SHELL;
our $NAME = 'angel';
our $VERBOSE = 0;
our $SHELL_PID = getppid();
our $TERM = $ENV{TERM};



$SIG{__DIE__} = sub {
    return if $^S;
    if (-t STDERR) {
        my $last = pop @_;
        $last =~ s/(\n)$//s;
        die "$RED$FindBin::Script: ", @_, $last, $NO_COLOR, ($1 ? ($1) : ());
    } else {
        die "$FindBin::Script: ", @_;
    }
};

if (-t STDERR) {
    $SIG{__WARN__} = sub {
        my $last = pop;
        $last =~ s/(\n)$//s;
        warn "$YELLOW$BOLD", @_, $last, $NO_COLOR, ($1 ? ($1) : ());
    };
}


sub interp
{
    my $state = shift;
    my @args = @_;
    for(my $i=0; $i<=$#args; $i++) {
        if (ref($args[$i]) eq 'CODE') {
            splice @args, $i, 1, interp($state, $args[$i]->($state));
            redo; # A dynamic part can return dynamic parts!
        }
    }
    return @args
}



# Compact a @PS1 definition: scalar refs are expanded to their escaped result
# and static strings are then concatenated.
sub compact
{
    my @template = @_;
    my @out;
    while (@template) {
        my $v = shift @template;
        my $r = ref $v;
        if ($r eq 'CODE') {
            push @out, $v;
            next;
        }
        # Reference followed by a scalar => replace by the expanded result
        if ($r eq 'ARRAY' && @template) {
            my $r = ref $template[0];
            if ($r && $r ne 'SCALAR') {
                push @out, $v, shift @template;
                next;
            }
            # Expand the color
            $v = colored($v, shift @template);
            $r = ref $v;
        }
        if ($r) {
            $v = $$v;
        } else {
            AngelPS1::Shell->ps1_escape($v);
        }
        if (@out && ref($out[$#out]) eq 'SCALAR') {
            ${$out[$#out]} .= $v
        } else {
            push @out, \$v;
        }
    }
    return @out if wantarray;
    die "invalid state after compact" if @out != 1 || ref $out[0] ne 'SCALAR';
    ${pop @out}
}

sub colored
{
    my @args = @_;
    my $out = '';
    my $color_str;
    while (@args) {
        my $v = shift @args;
        my $r = ref $v;
        if ($r eq 'ARRAY') {
            $color_str = $v->[0];
            # TODO ensure that color strings are already PS1-escaped
            $out .= AngelPS1::Shell->ps1_invisible($color_str);
            next;
        }
        #print STDERR "$r $v\n";
        $out .= $r ? $$v : AngelPS1::Shell->ps1_escape($v);
        if (defined $color_str) {
            $out .= AngelPS1::Shell->ps1_invisible($NO_COLOR);
            undef $color_str;
        }
    }
    return \$out
}

my @INCLUDES;

GetOptions(
    'version' => sub { print "angel-PS1 version $VERSION\n"; exit 0 },
    'shell=s' => \$SHELL,
    'name=s' => \$NAME,
    'v|verbose' => \$VERBOSE,
    'q|quiet' => sub { $VERBOSE = -1 },
    'debug'  => \$DEBUG,
    'I=s' => \@INCLUDES,
);

# Order is important: preserve the order as perl itself
lib->import(@INCLUDES);
undef @INCLUDES;

unless ($SHELL) {
    require AngelPS1::Util;
    # Extract the name of $PPID
    my $comm_file = "/proc/$SHELL_PID/comm";
    if (-f $comm_file && -r _) { # Linux shortcut
        open my $comm, '<', $comm_file;
        $SHELL = <$comm>
    } else {
        $SHELL = AngelPS1::Util::run(ps => qw(-o comm=), $SHELL_PID)
    }
    $SHELL = AngelPS1::Util::one_line($SHELL);
}

# Dynamically load our shell plugin
AngelPS1::Shell->use($SHELL);

# The angel name must be a valid shell function identifier
# Note that '-' is allowed, even as a first char
$NAME =~ /^[-A-Z_][-A-Z_0-9]*$/si or die "invalid angel name";



# Load the configuration from @INC
# Usually: $HOME/.config/angel-PS1/PS1.pl
my @PS1 = do { package AngelPS1::Prompt; do 'PS1.pl' };
die "Invalid configuration: $@" if $@;
pop @PS1 if @PS1 == 1 && !defined $PS1[0];


# If no custom config, load instead AngelPS1/Prompt/Default.pm
unless (@PS1) {
    package # Not indexed
            AngelPS1::Config;
    @PS1 = do 'AngelPS1/Prompt/Default.pm';
    die "Invalid configuration: $@" if $@;
}


@PS1 = compact @PS1;



my $FIFO_PATH = tmpnam().".$NAME-$$";
my $FIFO_IN = "$FIFO_PATH.in";
my $FIFO_OUT = "$FIFO_PATH.out";

if (-t STDOUT) {
    die "TERM is not set\n" unless exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

    unless ($ENCODING) {
        warn "Encoding not set in locale. Please set LC_CTYPE.\n";
    } elsif ($ENCODING !~ /^UTF-/i) {
        # Get the canonical name
        $ENCODING = Encode::find_encoding($ENCODING)->name;
        warn "Your locale is not set to a known Unicode encoding (such as 'UTF-8') but to '$ENCODING'. Please report your use case to the Angel PS1 developers.\n"
    }

    #print "${RED}Red!${NO_COLOR}\n";

    print "angel-PS1 $VERSION\n";

    my $script = index($0, '/') >= 0 ? $0 : "\$(which $FindBin::Script)";
    print "Copyright (C) 2013  Olivier Mengué\n",
          "This program comes with ABSOLUTELY NO WARRANTY;\n",
          "This is free software, and you are welcome to redistribute it\n",
          "under certain conditions;\n",
          "Run \"sed -n '2,19{s/.//;p}' $script | iconv -f UTF-8\" for details.\n\n";
    print STDERR "usage: eval `$0`\n";

    #print 'Running as an app: ', $APP, "\n";
    #print "\$Bin: $FindBin::Bin\n";
    #print "\$Script: $FindBin::Script\n";
    #print '__FILE__: ', __FILE__, "\n";
    #print "\%INC:\n  - ", join("\n  - ", sort keys %INC), "\n";
    #print "\@INC:\n  - ", join("\n  - ", @INC), "\n";

    exit 1;
}

# *****************************************************************************
# Angel startup
# *****************************************************************************

# No terminal? This is not an interactive shell.
# So we don't install.
exit 0 unless -t STDIN && exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

# If the prompt is static after compact(), just output it and don't install the
# angel. This allows the user to use the power of the angel-PS1 prompt compiler
# and plugins without the runtime cost.
if (@PS1 == 1 && (ref $PS1[0]) eq 'SCALAR') {
    (my $PS1 = ${$PS1[0]}) =~ s/'/'\\''/g;
    print qq{[[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave; PS1='$PS1'\n};
    exit 0
}


require POSIX;
POSIX::mkfifo($FIFO_IN, 0600) or die "Can't create fifo $FIFO_IN: $!";
POSIX::mkfifo($FIFO_OUT, 0600) or die "Can't create fifo $FIFO_OUT: $!";
-p $FIFO_IN && -o _ or die "Fifo $FIFO_IN creation failed.";
-p $FIFO_OUT && -o _ or die "Fifo $FIFO_OUT creation failed.";

print AngelPS1::Shell->shell_code(
    name  => $NAME,
    debug => $DEBUG,
    in    => $FIFO_IN,
    out   => $FIFO_OUT,
    env   => [qw< PWD >],
);

close STDIN;

my $child = fork();
die if $child == -1;
if ($child) {
    # We don't want the fifos to be removed by the END block
    undef $FIFO_IN;
    undef $FIFO_OUT;
    print "APS1_PID=$child\n";
    print STDERR "$NAME installed.\n" unless $VERBOSE < 0;
    exit 0;
}

# *****************************************************************************
# Angel forked
# *****************************************************************************

open STDIN, '+<', '/dev/null';
close STDOUT;
open STDOUT, '>', '/dev/null';


# Ignore ^C sent to the terminal
$SIG{INT} = sub {
    print STDERR "Ctrl+C !\n";
    #exit 0;
};
# Clean exits that will call our END block
$SIG{HUP} = $SIG{TERM} = sub { exit 0 };



# Bash PS1 fallback
my $PS1_fallback = compact("[$NAME sick!] ", \'\w\$ ');


# *****************************************************************************
# Angel main loop
# *****************************************************************************
sub main_loop
{
    my @PS1 = @_;

    my $FIFO;
    for (;;) {
        unless (open $FIFO, "<:encoding($ENCODING)", $FIFO_IN) {
            redo if -e $FIFO_IN && -p _;
            last;
        }
        $_ = do { undef $/; <$FIFO> };
        close $FIFO;
        printf STDERR "DEBUG< %s\n", do { (my $tmp = $_) =~ s/\0/ /g; $tmp } if $DEBUG;

        my %shell_state = map { ( m/^(.*?)=(.*)/s ) } split /\0/;

        chdir $shell_state{'PWD'};

        my $PS1 = eval { compact(interp(\%shell_state, @PS1)) };
        unless (defined $PS1) {
            (my $err = $@) =~ s/\s*$//s;
            print STDERR "$RED$BOLD$NAME PS1 eval: $err$NO_COLOR\n";
            $PS1 = $PS1_fallback;
        }

        open $FIFO, ">:encoding($ENCODING)", $FIFO_OUT;
        print $FIFO AngelPS1::Shell->ps1_finalize($PS1), "\n";
        close $FIFO;
    }
}

main_loop(@PS1);

END {
    no warnings 'uninitialized';
    unlink $FIFO_IN, $FIFO_OUT;
}

# vim:set et ts=8 sw=4 sts=4:
