#!/usr/bin/perl

#    Copyright © 2013 Olivier Mengué
#    Original source code is available at https://github.com/dolmen/angel-PS1
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"AngelPS1/Color.pm"} = <<'ANGELPS1_COLOR';
  use strict;
  use warnings;
  
  package AngelPS1::Color;
  
  use Exporter 'import';
  our @EXPORT = (qw($BLACK $RED $GREEN $YELLOW $BLUE $MAGENTA $CYAN $GRAY),
                 qw($NO_COLOR $BOLD));
  
  use AngelPS1::Util 'run';
  
  sub terminfo ($;@); # Pre-declare for recursion
  
  my %terminfo_cache;
  
  sub terminfo ($;@)
  {
      my ($capability, @args) = @_;
      if (ref $capability) {
          my $cap0 = $capability->[0];
          if (exists $terminfo_cache{"\0$cap0"}) {
              $capability = $terminfo_cache{"\0$cap0"}
          } else {
              for my $cap (@$capability) {
                  my $res = terminfo $cap, @args;
                  next if $res eq '';
                  $terminfo_cache{"\0$cap0"} = $cap if $cap ne $cap0;
                  return $res
              }
              return '';
          }
      }
  
      my $query = join("\0", $capability, @args);
      return $terminfo_cache{$query} if exists $terminfo_cache{$query};
  
      my $result = run(tput => $capability, @args);
  
      # Cache the result
      $terminfo_cache{$query} = $result;
  
      $result
  }
  
  sub setaf ($) { terminfo [ qw(setaf AF) ], $_[0] }
  
  our ($BLACK, $RED, $GREEN, $YELLOW, $BLUE, $MAGENTA, $CYAN, $GRAY) =
      map { setaf $_ } 0..7;
  our $BOLD = terminfo [ qw(bold md) ];
  our $NO_COLOR = terminfo [ qw(sgr0 me) ];
  
  '$';
  # vim:set et ts=8 sw=4 sts=4:
ANGELPS1_COLOR

$fatpacked{"AngelPS1/Compiler.pm"} = <<'ANGELPS1_COMPILER';
  use strict;
  use warnings;
  
  package AngelPS1::Compiler;
  
  use Exporter 'import';
  our @EXPORT = qw<compact interp ps1_is_static>;
  
  use AngelPS1::Shell ();
  use AngelPS1::Color '$NO_COLOR';
  
  
  sub interp
  {
      my $state = shift;
      my @args = @_;
      for(my $i=0; $i<=$#args; $i++) {
          if (ref($args[$i]) eq 'CODE') {
              splice @args, $i, 1, interp($state, $args[$i]->($state));
              redo; # A dynamic part can return dynamic parts!
          }
      }
      return @args
  }
  
  
  
  # Compact a @PS1 definition: bare scalar are expanded to their escaped result
  # and scalar refs are concatenated, and colors (ARRAY) are expanded.
  # CODE refs are preserved as is, so we can do a multiple step compilation.
  sub compact
  {
      my @template = @_;
      my @out;
      while (@template) {
          my $v = shift @template;
          my $r = ref $v;
          if ($r eq 'CODE') {
              push @out, $v;
              next;
          }
          # ARRAY followed by a scalar or scalar ref
          # => replace by the colored expanded result
          if ($r eq 'ARRAY' && @template) {
              my $r = ref $template[0];
              if ($r && $r ne 'SCALAR') {
                  push @out, $v, shift @template;
                  next;
              }
              # Expand the color
              $v = colored($v, shift @template);
              $r = ref $v;
          }
          if ($r) {
              $v = $$v;
          } else {
              $v = AngelPS1::Shell->ps1_escape($v);
          }
          if (@out && ref($out[$#out]) eq 'SCALAR') {
              ${$out[$#out]} .= $v
          } else {  # CODE refs (and anything else) are preserved
              push @out, \$v;
          }
      }
      return @out if wantarray;
      die "invalid state after compact" if @out != 1 || ref $out[0] ne 'SCALAR';
      ${pop @out}
  }
  
  # Process a list of mixed scalar, scalar refs and ARRAYs.
  # ARRAYS are specifications for colors that must be applied to the following
  # Returns a scalar ref that represents shell escaped text.
  sub colored
  {
      my @args = @_;
      my $out = '';
      my $color_str;
      while (@args) {
          my $v = shift @args;
          my $r = ref $v;
          if ($r eq 'ARRAY') {
              $color_str = $v->[0];
              # TODO ensure that color strings are already PS1-escaped
              $out .= compact(AngelPS1::Shell->ps1_invisible($color_str));
              next;
          }
          #print STDERR "$r $v\n";
          $out .= $r ? $$v : AngelPS1::Shell->ps1_escape($v);
          if (defined $color_str) {
              $out .= compact(AngelPS1::Shell->ps1_invisible($NO_COLOR));
              undef $color_str;
          }
      }
      return \$out
  }
  
  
  sub ps1_is_static
  {
      my $PS1 = shift;
      $#$PS1 == 1 && (ref $PS1->[0]) eq 'SCALAR'
  }
  
  
  '$';
  # vim:set et ts=8 sw=4 sts=4:
ANGELPS1_COMPILER

$fatpacked{"AngelPS1/Plugin.pm"} = <<'ANGELPS1_PLUGIN';
  use strict;
  use warnings;
  
  package AngelPS1::Plugin;
  
  our $VERSION = $AngelPS1::VERSION;
  
  use Exporter 5.57 'import';
  our @EXPORT = qw(compact interp);
  
  *compact = \&AngelPS1::compact;
  *interp = \&AngelPS1::interp;
  
  '$';
  # vim:set et ts=8 sw=4 sts=4:
ANGELPS1_PLUGIN

$fatpacked{"AngelPS1/Plugin/Core.pm"} = <<'ANGELPS1_PLUGIN_CORE';
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::Core;
  
  our $VERSION = $AngelPS1::VERSION;
  
  use Exporter 5.57 'import';
  our @EXPORT = qw(Escape MarginLeft);
  
  use AngelPS1::Plugin;
  
  
  sub Escape
  {
      my @content = compact(@_);
      sub {
          my @result = interp @content;
          \ compact(@result);
      }
  }
  
  sub MarginLeft
  {
      my $code = pop;
      my $margin = shift;
      $margin = ' ' unless defined $margin;
      sub {
          my @result = interp $code;
          return unless @result;
          ($margin, @result)
      }
  }
  
  '$';
  # vim:set et ts=8 sw=4 sts=4:
ANGELPS1_PLUGIN_CORE

$fatpacked{"AngelPS1/Plugin/Git.pm"} = <<'ANGELPS1_PLUGIN_GIT';
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::Git;
  
  use Exporter 5.57 'import';
  BEGIN {
      our $VERSION = $AngelPS1::VERSION;
      our @EXPORT = qw(GitInfo);
  }
  
  use AngelPS1::Util qw< which run one_line >;
  use AngelPS1::Color;
  
  my $git = eval { which 'git' };
  sub git
  {
      # All Git commands we call return a single line. We don't want '\n'
      one_line(run $git, @_)
  }
  
  sub GitInfo
  {
      unless ($git) {
          warn "'git' not found in PATH";
          return
      }
  
      # Cleanup the environment
      # This is done globally!
      delete @ENV{qw< GIT_DIR GIT_TRACE >};
  
      # Return a dynamic PS1 element
      sub {
          my $shell_state = shift;
  
          my $git_dir = "$shell_state->{'PWD'}/.git";
          unless (-d $git_dir) {
              ($git_dir = git qw(rev-parse --git-dir))
                  or return;
          }
          # This seems to be incompatible with "git diff --shortstat"
          #local $ENV{'GIT_DIR'} = $git_dir;
  
          my @out;
          my $local_commits = 0;
  
          my $branch = git 'symbolic-ref', 'HEAD';
          if ($branch eq '') {
              ($branch = git 'rev-parse', '--short')
                  or return;
          } else {
              $branch =~ s{^refs/heads/}{};
  
              # Count the number of commits to push ($local_commits)
              if ((my $remote_branch = git qw(config --get), "branch.$branch.merge")
                  && (my $remote = git qw(config --get), "branch.$branch.remote")) {
  
                  # Compute the ref of our local image of the remote branch
                  (my $remote_branch_ref = $remote_branch) =~ s{^refs/heads/}{refs/remotes/$remote/};
  
                  # Count the commits
                  $local_commits =
                      git(qw(rev-list --no-merges --count),
                          "$remote_branch_ref..HEAD")
                      || 0;
              }
          }
  
          my $status = git qw(status --porcelain -z);
          my $untracked = $status =~ /(?:^|\0)\?\? /s;
  
          if ((my $shortstat = git qw(diff --shortstat)) && ($? >> 8) == 0) {
              my ($ins) = ($shortstat =~ /([0-9]+) insertions?\(/);
              my ($del) = ($shortstat =~ /([0-9]+) deletions?\(/);
  
              push @out,
                  [ $RED ], $branch,
                  '(',
                      [ $MAGENTA ],
                      ($ins ? ("+$ins" . ($del ? "/" : '')) : '') . ($del ? "-$del" : ''),
                      ($local_commits ? (',', [ $YELLOW ], $local_commits) : ()),
                  ')';
          } elsif ($local_commits) {
              push @out,
                  [ $YELLOW ], $branch,
                  '(', [ $YELLOW ], $local_commits, ')';
          } else {
              push @out, [ $GREEN ], $branch;
          }
  
          if (-f "$git_dir/refs/stash") {
              push @out, [ $RED ], '+';
          }
  
          if ($untracked) {
              push @out, [ $RED ], '*';
          }
  
          # TODO Git mark
  
          @out, ' '
      }
  }
  
  '$';
  # vim:set et ts=8 sw=4 sts=4:
ANGELPS1_PLUGIN_GIT

$fatpacked{"AngelPS1/Plugin/TerminalSize.pm"} = <<'ANGELPS1_PLUGIN_TERMINALSIZE';
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::TerminalSize;
  
  our $VERSION = $AngelPS1::VERSION;
  
  use Exporter 5.57 ();
  our @ISA = 'Exporter';
  our @EXPORT = qw($LINES $COLUMNS);
  
  our ($LINES, $COLUMNS);
  
  # Get the ioctl number
  my $TIOCGWINSZ =
      # Shortcut static table
      {
          # $^O => ioctl TIOCGWINSZ constant
          linux => 0x5413,
      }->{$^O}
  ||
      # Fallback: get the constant from ioctl.ph
      eval {
          package AngelPS1::Plugin::TerminalSize::ioctl;
          require 'sys/ioctl.ph';
          delete $INC{'sys/ioctl.ph'};
          \&TIOCGWINSZ
      };
  
  
  my $_WINSZ = pack('S4');
  
  sub _update_from_ioctl
  {
      ioctl(STDERR, $TIOCGWINSZ, $_WINSZ);
      ($LINES, $COLUMNS) = unpack('S2', $_WINSZ);
  }
  
  my $TTYNAME;
  sub _update_from_stty
  {
      my $line = `stty -F $TTYNAME size`;
      ($LINES, $COLUMNS) = split / /, $line;
  }
  
  # TODO If sys/ioctl.ph is not available, try:
  # - Term::Size
  # - Term::ReadKey
  # - stty size
  # - hardcoded value of TIOCGWINSZ based on $^O
  # See also perlfaq8: How do I get the screen size?
  
  
  sub import
  {
      # Avoid multiple install due to multiple import from different packages
      unless ($SIG{WINCH}) {
          if (defined $TIOCGWINSZ) {
              # Terminal size change
              $SIG{WINCH} = \&_update_from_ioctl;
          } else {
              require POSIX;
              $TTYNAME = POSIX::ttyname(2); # STDERR
              $SIG{WINCH} = \&_update_from_stty;
          }
  
          # Fetch now
          $SIG{WINCH}->();
      }
  
      $_[0]->export_to_level(1, @_);
  }
  
  '$';
  # vim:set et ts=8 sw=4 sts=4:
ANGELPS1_PLUGIN_TERMINALSIZE

$fatpacked{"AngelPS1/Prompt/Default.pm"} = <<'ANGELPS1_PROMPT_DEFAULT';
  use strict;
  use warnings;
  
  package AngelPS1::Prompt::Default;
  
  use AngelPS1::Shell ();
  use AngelPS1::Color;
  use AngelPS1::Plugin::Core;
  use AngelPS1::Plugin::TerminalSize;
  use AngelPS1::Plugin::Git;
  
  use POSIX ();
  
  (my $TTYNAME = POSIX::ttyname(0)) =~ s{^/dev/}{};
  
  return () unless AngelPS1::Shell->can('WorkingDir')
                && AngelPS1::Shell->can('UserPrivSymbol');
  
  # The prompt is the list returned as the last statement
  (
      (AngelPS1::Shell->name, ' ') x!! %AngelPS1::DEBUG,
      [ $BLUE ],
      sub { sprintf('%3$02d:%2$02d:%1$02d', localtime) },
      ' ',
      $TTYNAME,
      (sub { "(${COLUMNS}x${LINES})" }) x!! %AngelPS1::DEBUG,
      ' ',
      # User name
      $< ? (scalar getpwuid $<) : (),
      sub { ((-w $_[0]->{PWD} ? [ $GREEN ] : [ $RED ]), ':') },
      AngelPS1::Shell->WorkingDir,
      ' ',
      GitInfo,
      sub { my $err = $_[0]->{'?'}; $err == 0 ? () : ([ $RED ], $err, ' ') },
      # User mark: root => #    else  $
      ($< ? ([ $BOLD ], AngelPS1::Shell->UserPrivSymbol) : ([ "$BOLD$RED" ], '#')),
      ' ',
  )
  # vim:set et ts=8 sw=4 sts=4:
ANGELPS1_PROMPT_DEFAULT

$fatpacked{"AngelPS1/Shell.pm"} = <<'ANGELPS1_SHELL';
  use strict;
  use warnings;
  
  package AngelPS1::Shell;
  
  my %ALIASES = (
      ksh   => 'mksh',
      ksh88 => 'mksh',
      ksh93 => 'mksh',
  );
  
  
  my $name;
  
  #
  # Call: AngelPS1::Shell->name
  #
  sub name
  {
      $name
  }
  
  #
  # Call: AngelPS1::Shell->use('bash')
  #
  sub use
  {
      my ($class, $shell) = @_;
      if ($shell) {
          $shell = $ALIASES{$shell} if exists $ALIASES{$shell};
          my $src = "AngelPS1/Shell/$shell.pm";
          unless (exists $INC{$src}) {
              # TODO try to distinguish load errors (file not found) from compile errors
              # by pushing a sub on @INC that will be called.
              die "$shell is not a supported shell.\n" unless eval { require $src };
              my $pkg = "${class}::$shell";
              # Make AngelPS1::Shell a sub class of $pkg
              our @ISA = ($pkg);
              $name = $shell;
          }
      }
  }
  
  '$';
  # vim:set et ts=8 sw=4 sts=4:
ANGELPS1_SHELL

$fatpacked{"AngelPS1/Shell/bash.pm"} = <<'ANGELPS1_SHELL_BASH';
  use strict;
  use warnings;
  
  package AngelPS1::Shell::bash;
  
  
  sub ps1_escape
  {
      (my $s = $_[1]) =~ s{([\\\$`])}{\\$1}gs;
      $s
  }
  
  sub ps1_invisible
  {
      shift; # $class
      (\'\[', @_, \'\]')
  }
  
  
  sub ps1_finalize
  {
      # Escape the first and last space using bash PS1 encoding as 'read' removes spaces
      # at beginning and end of line
      (my $PS1 = $_[1]) =~ s/^ | $/\\040/g;
      # Escape \ as 'read' expands them
      $PS1 =~ s/\\/\\\\/g;
      # Escape newlines
      $PS1 =~ s/\n/\\\n/g;
      "$PS1\n"
  }
  
  # Returns the code to send to the shell
  sub shell_code
  {
      my ($class, %options) = @_;
      my ($DEBUG, $NAME, $IN, $OUT, $PID, $env) =
          @options{qw<debug name in out pid env>};
  
      my $shell_debug = $DEBUG->{'in'} ? q|printf 'DEBUG> PS1=%q\\n' "$PS1" ; | : '';
      my $time_debug = $DEBUG->{'time'} ? q|time | : '';
  
      # The shell code will be evaluated with eval as a single line
      # so statements must be properly terminated with ';'
      # No shell comments allowed
      <<EOF;
  [[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave;
  APS1_PS1="\$PS1";
  APS1_PROMPT_COMMAND="\$PROMPT_COMMAND";
  -angel-PS1()
  {
      local err=\$?;
      [[ -e '$IN' ]] || { $NAME leave ; return ; };
      printf '%s\\0%s' "?=\$err" "PWD=\$PWD" > '$IN' || { $NAME leave ; return ; };
      read PS1 < '$OUT' || $NAME leave ;
      $shell_debug
  } ;
  PROMPT_COMMAND='${time_debug}-angel-PS1' ;
  APS1_NAME=$NAME ;
  APS1_PID=$PID ;
  $NAME()
  {
      case "\$1" in
      leave|quit|go-away)
          PROMPT_COMMAND="\$APS1_PROMPT_COMMAND" ;
          PS1="\$APS1_PS1" ;
          kill \$APS1_PID 2>/dev/null ;
          rm -f -- '$IN' '$OUT' ;
          unset APS1_PS1 APS1_PID APS1_NAME ;
          unset -f -- $NAME -angel-PS1 ;;
      mute|off)
          PROMPT_COMMAND="\$APS1_PROMPT_COMMAND" ;
          PS1="\$APS1_PS1" ;;
      unmute|on)
          PROMPT_COMMAND=-angel-PS1 ;;
      *)
          echo 'usage: $NAME [quit|mute|off|unmute|on]' >&2 ;
          return 1 ;;
      esac ;
  } ;
  trap '$NAME leave' EXIT ;
  EOF
  
  }
  
  
  sub WorkingDir
  {
      \'\w'
  }
  
  sub UserPrivSymbol
  {
      \'\$'
  }
  
  '$';
  # vim:set et ts=8 sw=4 sts=4:
ANGELPS1_SHELL_BASH

$fatpacked{"AngelPS1/Shell/mksh.pm"} = <<'ANGELPS1_SHELL_MKSH';
  use strict;
  use warnings;
  
  package AngelPS1::Shell::mksh;
  
  use constant INVIS_CHAR => "\x01";
  
  sub ps1_escape
  {
      (my $s = $_[1]) =~ s/!/!!/gs;
      $s =~ s{([\\\$`])}{\\$1}gs;
      # TODO remove INVIS_CHAR
      $s
  }
  
  sub ps1_invisible
  {
      shift; # $class
      (\INVIS_CHAR, @_, \INVIS_CHAR)
  }
  
  sub ps1_finalize
  {
      my $PS1 = $_[1];
      substr($PS1, 0, 0, INVIS_CHAR . "\r") if index($PS1, INVIS_CHAR) >= 0;
      $PS1
  }
  
  sub shell_code
  {
      my ($class, %options) = @_;
      my ($DEBUG, $NAME, $IN, $OUT, $PID, $env) =
          @options{qw<debug name in out pid env>};
  
      my $time_debug = $DEBUG->{'time'} ? q|time -- | : '';
  
      # The shell code will be evaluated with eval as a single line
      # so statements must be properly terminated with ';'
      # No shell comments allowed
      <<EOF;
  [[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave;
  APS1_PS1="\$PS1";
  -angel-PS1()
  {
      local err=\$?;
      [[ -e '$IN' ]] || { eval "echo '\$APS1_PS1'"; $NAME leave ; return ; };
      printf '%s\\0%s' "?=\$err" "PWD=\$PWD" > '$IN' || { eval "echo '\$APS1_PS1'"; $NAME leave ; return ; };
      cat $OUT || $NAME leave ;
  } ;
  PS1='\$(${time_debug}-angel-PS1)' ;
  APS1_NAME=$NAME ;
  APS1_PID=$PID ;
  $NAME()
  {
      case "\$1" in
      leave|quit|go-away)
          PS1="\$APS1_PS1" ;
          kill \$APS1_PID 2>/dev/null ;
          rm -f -- '$IN' '$OUT' ;
          unset APS1_PS1 APS1_PID APS1_NAME ;
          unset -f -- $NAME -angel-PS1 ;;
      mute|off)
          PS1="\$APS1_PS1" ;;
      unmute|on)
          PS1='\$(${time_debug}-angel-PS1)' ;;
      *)
          echo 'usage: $NAME [quit|mute|off|unmute|on]' >&2 ;
          return 1 ;;
      esac ;
  } ;
  trap '$NAME leave' EXIT ;
  EOF
  }
  
  sub WorkingDir
  {
      my $home = $ENV{'HOME'};
      sub {
          my $pwd = $_[0]->{'PWD'};
          $pwd =~ s{^$home/}{~/}s;
          $pwd
      }
  }
  
  sub UserPrivSymbol
  {
      \( $< ? '$' : '#' )
  }
  
  '$';
  # vim:set et ts=8 sw=4 sts=4:
ANGELPS1_SHELL_MKSH

$fatpacked{"AngelPS1/Shell/tcsh.pm"} = <<'ANGELPS1_SHELL_TCSH';
  use strict;
  use warnings;
  
  package AngelPS1::Shell::tcsh;
  
  sub ps1_escape
  {
      # csh special symbols
      (my $s = $_[1]) =~ s{%}{%%}gs;
      # csh special sequences for special chars, à la bindkey
      $s =~ s{\\}{\\\\}gs;
      $s =~ s{\^}{\\136}gs;
      # csh special: history number
      $s =~ s{!}{\\041}gs;
      # \n must be escaped as tcsh replaces it with space in backquote (`) output
      $s =~ s{\n}{\\n}gs;
      #print STDERR "Escape [$_[1]] => [$s]\n";
      $s
  }
  
  sub ps1_invisible
  {
      shift; # $class
      (\'%{', @_, \'%}')
  }
  
  sub ps1_finalize
  {
      my $prompt = $_[1];
      $prompt =~ s/'/'\\''/g;
      # tcsh replaces '\n' with a space in command substitution (backquotes: `)
      # so '\n' will be lost in our current implementation
      # TODO: try to replace with '\\n'
      warn "Prompt has '\\n' This is not supported by angel-PS1!" if $prompt =~ /\n/;
      qq{set prompt = '$prompt'};
  }
  
  sub shell_code
  {
      my ($class, %options) = @_;
      my ($DEBUG, $NAME, $IN, $OUT, $PID, $env) =
          @options{qw<debug name in out pid env>};
  
      # Reference for this csh shit:
      # - http://www.grymoire.com/Unix/CshTop10.txt
      # - http://www.faqs.org/faqs/unix-faq/shell/csh-whynot/
  
      my $shell_code = <<EOF;
  if ( \${?aps1_name} ) then
      eval \$aps1_name leave
  endif
  set aps1_prompt = \$prompt:q
  set aps1_precmd = 'if ( -p $IN ) then\\
      echo -n "?=\$?:q\\0PWD=\$PWD:q" > $IN\\
      eval "`cat $OUT`"\\
  else\\
      $NAME leave\\
  endif'
  alias precmd \$aps1_precmd:q
  alias $NAME 'switch ( \\!* )\\
      case leave:\\
      case quit:\\
          set prompt = "\$aps1_prompt:q"\\
          kill \$aps1_pid\\
          rm -f -- $IN $OUT\\
          unset aps1_prompt aps1_pid aps1_name aps1_precmd\\
          unalias precmd $NAME\\
          breaksw\\
      case off:\\
      case mute:\\
          unalias precmd\\
          set prompt = \$aps1_prompt:q\\
          breaksw\\
      case on:\\
      case unmute:\\
          alias precmd \$aps1_precmd:q\\
          :\\
          breaksw\\
      default:\\
          echo "$NAME: unknown option"\\
          echo "usage: $NAME [quit|mute|off|unmute|on]"\\
          breaksw\\
  endsw'
  set aps1_name = '$NAME'
  set aps1_pid = '$PID'
  EOF
  # For debugging
  #alias $NAME-kill 'set prompt = \$aps1_prompt:q; kill \$aps1_pid >/dev/null; unset aps1_prompt aps1_pid aps1_name aps1_precmd; unalias precmd $NAME $NAME-kill; :'
  
      # Inside backquotes (`) output \n are replaced with spaces by tcsh
      # So switch/if can not work.
      # Workaround: save the shell code to a file, and source it.
      require POSIX;
      my $file = POSIX::tmpnam()."$$.tcsh";
      # TODO encoding, as the angel name may not be ascii
      open my $f, '>', $file;
      print $f $shell_code;
      close $f;
  
      # Return value, passed as the eval argument
      # aps1_pid assignment will be concatenated
      #"cat $file; " . # For debugging
      "source $file; rm -f $file"
  }
  
  sub WorkingDir
  {
      \'%~'
  }
  
  sub UserPrivSymbol
  {
      # The 'promptchars' variable defines exactly what will be displayed
      \'%#'
  }
  
  '$';
  # vim:set et ts=8 sw=4 sts=4:
ANGELPS1_SHELL_TCSH

$fatpacked{"AngelPS1/Util.pm"} = <<'ANGELPS1_UTIL';
  use strict;
  use warnings;
  
  package AngelPS1::Util;
  
  use Exporter 'import';
  our @EXPORT_OK = qw<which run one_line>;
  
  use IPC::Open3 ();
  use Symbol 'gensym';
  
  
  {
      my @PATH;
      BEGIN { @PATH = split /:/, $ENV{'PATH'}; }
      my %which;
  
      sub which ($)
      {
          my ($name, $no_cache) = @_;
  
          # Use the cache
          return $which{$name} if exists $which{$name};
          # Already a path with a directory?
          return $name if index($name, '/') >= 0;
  
          # Search in $PATH
          foreach my $p (@PATH) {
              my $f = "$p/$name";
              if (-x $f && ! -d _) {
                  $which{$name} = $f unless $no_cache;
                  return $f;
              }
          }
          die "$name: not found";
      }
  }
  
  sub run
  {
      my $command = which(shift);
      my ($in, $out);
      my $err = gensym;
      my $pid = IPC::Open3::open3(
          $in,
          $out,
          $err,
          $command,
          @_
      );
      my $result = do { undef $/; readline $out };
      # TODO UTF-8 decoding
      waitpid($pid, 0);
      return $result
  }
  
  sub one_line
  {
      # chop
      (my $result = shift) =~ s{\n$}{}s;
      $result
  }
  
  '$';
  # vim:set et ts=8 sw=4 sts=4:
ANGELPS1_UTIL

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    if ($] < 5.008) {
      return sub {
        return 0 unless length $fat;
        $fat =~ s/^([^\n]*\n?)//;
        $_ = $1;
        return 1;
      };
    }
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE

use utf8;

#    Copyright © 2013 Olivier Mengué
#    Original source code is available at https://github.com/dolmen/angel-PS1
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.



use 5.008003;  # 5.010 is the sane minimum
use strict;
use warnings;

package AngelPS1;

our $VERSION = '0.03';

use Getopt::Long qw(:config posix_default no_ignore_case auto_help);
use POSIX ();
use Encode ();
use FindBin;

# TODO build.pl should inline those modules
use AngelPS1::Shell ();
use AngelPS1::Compiler;
use AngelPS1::Color;

use lib "$ENV{HOME}/.config/angel-PS1", '/etc/angel-PS1';


# Extract encoding name from the locale
our $ENCODING = do {
    # Shortcut for the most common case
    my $locale = $ENV{LC_ALL} || $ENV{LC_CTYPE} || $ENV{LANG} || 'POSIX';
    $locale =~ /\.UTF-?8(?:@.*)?$/i
        ? 'UTF-8'
        : do {
            # warn "slow locale lookup...";
            POSIX::setlocale(POSIX::LC_CTYPE(), '');
            require I18N::Langinfo;
            eval { I18N::Langinfo::langinfo(I18N::Langinfo::CODESET()) }
                or do { warn $@; undef }
        }
};

# Decode @ARGV and encode STDOUT, STDERR
if ($ENCODING) {
    my $encoding_obj = Encode::find_encoding($ENCODING);
    map { $_ = $encoding_obj->decode($_) } @ARGV;
    binmode(STDOUT, ":encoding($ENCODING)");
    binmode(STDERR, ":encoding($ENCODING)");
}

our $APP = !defined scalar caller;  # Running as command or include
$main::VERSION = $VERSION if $APP;
my @DEBUG_DEFAULTS = qw<in time>;
our %DEBUG = $ENV{APS1_DEBUG}
    ? (map { ($_ => 1) }
        ($ENV{APS1_DEBUG} eq '1'
        ? (split /,/, $ENV{APS1_DEBUG})
        : @DEBUG_DEFAULTS))
    : ();
our $SHELL;
our $NAME = 'angel';
our $VERBOSE = 0;
our $SHELL_PID = getppid();
our $TERM = $ENV{TERM};
my $CONFIG;



$SIG{__DIE__} = sub {
    return if $^S;
    if (-t STDERR) {
        my $last = pop @_;
        $last =~ s/(\n)$//s;
        die "$RED$FindBin::Script: ", @_, $last, $NO_COLOR, ($1 ? ($1) : ());
    } else {
        die "$FindBin::Script: ", @_;
    }
};

if (-t STDERR) {
    $SIG{__WARN__} = sub {
        my $last = pop;
        $last =~ s/(\n)$//s;
        warn "$YELLOW$BOLD", @_, $last, $NO_COLOR, ($1 ? ($1) : ());
    };
}



my @INCLUDES;

GetOptions(
    'version' => sub { print "angel-PS1 version $VERSION\n"; exit 0 },
    'shell=s' => \$SHELL,
    'name=s' => \$NAME,
    'c|config=s' => \$CONFIG,
    'v|verbose' => \$VERBOSE,
    'q|quiet' => sub { $VERBOSE = -1 },
    'debug:s'  => sub {
        my $value = $_[1];
        if ($value eq '' || $value eq '1') {
            %DEBUG = (%DEBUG, map { ($_ => 1) } @DEBUG_DEFAULTS)
        } else {
            $DEBUG{$_} = 1 for split /,/, $value
        }
    },
    'I=s' => \@INCLUDES,
);

$CONFIG = 'PS1.pl' unless defined $CONFIG;

# Order is important: preserve the order as perl itself
lib->import(@INCLUDES);
undef @INCLUDES;

unless ($SHELL) {
    require AngelPS1::Util;
    # Extract the name of $PPID
    my $comm_file = "/proc/$SHELL_PID/comm";
    if (-f $comm_file && -r _) { # Linux shortcut
        open my $comm, '<', $comm_file;
        $SHELL = <$comm>
    } else {
        $SHELL = AngelPS1::Util::run(ps => qw(-o comm=), $SHELL_PID)
    }
    $SHELL = AngelPS1::Util::one_line($SHELL);
}

# Dynamically load our shell plugin
AngelPS1::Shell->use($SHELL);

# The angel name must be a valid shell function identifier
# Note that '-' is allowed, even as a first char
$NAME =~ /^[-A-Z_][-A-Z_0-9]*$/si or die "invalid angel name";



# Load the configuration from @INC
# Usually: $HOME/.config/angel-PS1/PS1.pl
my @PS1 = do { package AngelPS1::Prompt; do $CONFIG };
die "Invalid configuration: $@" if $@;
pop @PS1 if @PS1 == 1 && !defined $PS1[0];


# If no custom config, load instead AngelPS1/Prompt/Default.pm
unless (@PS1) {
    package # Not indexed
            AngelPS1::Config;
    @PS1 = do 'AngelPS1/Prompt/Default.pm';
    die "Invalid configuration: $@" if $@;
    print STDERR "${NAME}'s config: AngelPS1::Prompt::Default\n" if $DEBUG{config};
} else {
    print STDERR "${NAME}'s config: ", $CONFIG, ' => ', $INC{$CONFIG}, "\n" if $DEBUG{config};
}


@PS1 = compact @PS1;


# Build the FIFO paths
my $FIFO_PATH = POSIX::tmpnam().".$NAME-$$";
my $FIFO_IN = "$FIFO_PATH.in";
my $FIFO_OUT = "$FIFO_PATH.out";

if (-t STDOUT) {
    die "TERM is not set\n" unless exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

    unless ($ENCODING) {
        warn "Encoding not set in locale. Please set LC_CTYPE.\n";
    } elsif ($ENCODING !~ /^UTF-/i) {
        # Get the canonical name
        $ENCODING = Encode::find_encoding($ENCODING)->name;
        warn "Your locale is not set to a known Unicode encoding (such as 'UTF-8') but to '$ENCODING'. Please report your use case to the Angel PS1 developers.\n"
    }

    #print "${RED}Red!${NO_COLOR}\n";

    print "angel-PS1 $VERSION\n";

    my $script = index($0, '/') >= 0 ? $0 : "\$(which $FindBin::Script)";
    print "Copyright (C) 2013  Olivier Mengué\n",
          "This program comes with ABSOLUTELY NO WARRANTY;\n",
          "This is free software, and you are welcome to redistribute it\n",
          "under certain conditions;\n",
          "Run \"sed -n '2,19{s/.//;p}' $script | iconv -f UTF-8\" for details.\n\n";
    print STDERR "usage: eval `$0`\n";

    #print 'Running as an app: ', $APP, "\n";
    #print "\$Bin: $FindBin::Bin\n";
    #print "\$Script: $FindBin::Script\n";
    #print '__FILE__: ', __FILE__, "\n";
    #print "\%INC:\n  - ", join("\n  - ", sort keys %INC), "\n";
    #print "\@INC:\n  - ", join("\n  - ", @INC), "\n";

    exit 1;
}

# *****************************************************************************
# Angel startup
# *****************************************************************************

# No terminal? This is not an interactive shell.
# So we don't install.
exit 0 unless -t STDIN && exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

# If the prompt is static after compact(), just output it and don't install the
# angel. This allows the user to use the power of the angel-PS1 prompt compiler
# and plugins without the runtime cost.
if (ps1_is_static(\@PS1) && AngelPS1::Shell->name !~ /csh$/) {
    (my $PS1 = ${$PS1[0]}) =~ s/'/'\\''/g;
    print qq{[[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave; PS1='$PS1'\n};
    exit 0
}


POSIX::mkfifo($FIFO_IN, 0600) or die "Can't create fifo $FIFO_IN: $!";
POSIX::mkfifo($FIFO_OUT, 0600) or die "Can't create fifo $FIFO_OUT: $!";
-p $FIFO_IN && -o _ or die "Fifo $FIFO_IN creation failed.";
-p $FIFO_OUT && -o _ or die "Fifo $FIFO_OUT creation failed.";

my $child = fork();
die if $child == -1;
if ($child) {
    print AngelPS1::Shell->shell_code(
        name  => $NAME,
        debug => \%DEBUG,
        in    => $FIFO_IN,
        out   => $FIFO_OUT,
        env   => [qw< PWD >],
        pid   => $child,
    );

    print STDERR "$NAME installed.\n" unless $VERBOSE < 0;

    # We don't want the fifos to be removed by the END block
    undef $FIFO_IN;
    undef $FIFO_OUT;

    exit 0;
}

# *****************************************************************************
# Angel forked
# *****************************************************************************

$0 = qq{$FindBin::Script $NAME};

open STDIN, '+<', '/dev/null';
close STDOUT;
open STDOUT, '>', '/dev/null';


# Ignore ^C sent to the terminal
$SIG{INT} = sub {
    print STDERR "Ctrl+C !\n";
    #exit 0;
};
# Clean exits that will call our END block
$SIG{HUP} = $SIG{TERM} = sub { exit 0 };



# PS1 fallback, if something goes wrong with the user defined prompt
my $PS1_fallback = do {
    my @fallback = compact(
        "[$NAME sick!] ",
        AngelPS1::Shell->WorkingDir,
        AngelPS1::Shell->UserPrivSymbol,
        ' ',
    );

        ps1_is_static(\@fallback)
    ? do { my $fallback = ${$fallback[0]}; sub { $fallback } }
    : sub { scalar compact(interp(@_, @fallback)) }
};


# *****************************************************************************
# Angel main loop
# *****************************************************************************
sub main_loop
{
    my @PS1 = @_;

    my $FIFO;
    for (;;) {
        unless (open $FIFO, "<:encoding($ENCODING)", $FIFO_IN) {
            redo if -e $FIFO_IN && -p _;
            last;
        }
        $_ = do { undef $/; <$FIFO> };
        close $FIFO;
        printf STDERR "DEBUG< %s\n", do { (my $tmp = $_) =~ s/\0/ /g; $tmp } if $DEBUG{'in'};

        my %shell_state = map { ( m/^(.*?)=(.*)/s ) } split /\0/;

        chdir $shell_state{'PWD'};

        my $PS1 = eval { compact(interp(\%shell_state, @PS1)) };
        unless (defined $PS1) {
            (my $err = $@) =~ s/\s*$//s;
            print STDERR "$RED$BOLD$NAME PS1 eval: $err$NO_COLOR\n";
            $PS1 = $PS1_fallback->(\%shell_state);
        }

        open $FIFO, ">:encoding($ENCODING)", $FIFO_OUT;
        print $FIFO AngelPS1::Shell->ps1_finalize($PS1);
        close $FIFO;
    }
}

main_loop(@PS1);

END {
    no warnings 'uninitialized';
    unlink $FIFO_IN, $FIFO_OUT;
}

# vim:set et ts=8 sw=4 sts=4:
