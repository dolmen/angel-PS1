#!/usr/bin/env perl

#    Copyright © 2013-2016 Olivier Mengué
#    Original source code is available at https://github.com/dolmen/angel-PS1
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"AngelPS1.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1';
  package AngelPS1;
  
  use POSIX ();
  
  our $VERSION = '0.96';
  
  our $SHELL_PID = getppid;
  
  our $NAME = 'angel';
  
  our $VERBOSE = 0;
  
  (our $TTYNAME = POSIX::ttyname(0)) =~ s{^/dev/}{};
  
  our $ENCODING;
  
  my $encoding;
  
  sub _str_allowed
  {
      my $str = shift;
      $encoding ||= do {
  	require Encode;
  	Encode::find_encoding($ENCODING)
      };
      local $@;
      eval { Encode::encode($encoding, $str, Encode::FB_CROAK()) };
      # Return true if no exception was thrown
      !$@
  }
  
  1;
ANGELPS1

$fatpacked{"AngelPS1/Chrome.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_CHROME';
  use strict;
  use warnings;
  
  package AngelPS1::Chrome;
  
  use Term::Chrome 1.011;
  
  *EXPORT = *Term::Chrome::EXPORT;
  *import = *Term::Chrome::import;
  
  1
ANGELPS1_CHROME

$fatpacked{"AngelPS1/Compiler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_COMPILER';
  use strict;
  use warnings;
  
  package AngelPS1::Compiler;
  
  use Exporter 'import';
  our @EXPORT = qw< reduce expand ps1_is_static >;
  
  use AngelPS1::Shell ();
  use Term::Chrome 2.000 ();
  use Scalar::Util ();
  
  
  sub expand
  {
      my $state = shift;
      die "expand(): invalid arg" unless ref($state) eq 'HASH';
      my @args = @_;
      LOOP: for(my $i=0; $i<=$#args; $i++) {
          #warn $i;
          my $r = ref $args[$i];
          if ($r eq 'CODE') {
              #use B 'svref_2object';
              #my $GV = svref_2object($args[$i])->GV;
              #warn('expanding sub '.$GV->SAFENAME.' defined at '.$GV->FILE.' line '.$GV->LINE);
              #undef $GV;
              my @tmp = $args[$i]->($state);
              splice @args, $i, 1, @tmp;
              #warn "OK";
              redo LOOP; # A dynamic part can return dynamic parts!
          } elsif ($r eq 'ARRAY') {
              $args[$i] = [ expand($state, @{$args[$i]}) ];
          }
      }
      return @args
  }
  
  sub reduce;
  
  sub reduce
  {
      my @template = @_;
      my @out;
      LOOP: while (@template) {
          my $v = shift @template;
          if (my $r = ref $v) {
              # Scalar refs are for raw (non-escaped) strings
              if ($r eq 'SCALAR') {
                  $v = $$v;
              }
              # => replace by the colored expanded result
              elsif (Scalar::Util::blessed($v) && $v->isa('Term::Chrome')) {
                  if (@template && ref($template[0]) eq 'ARRAY') {
                      my $arr = shift @template;
                      if (@$arr) { # If non-empty
                          unshift @template,
                              AngelPS1::Shell->ps1_invisible($v->term),
                              # flatten the ARRAY
                              @$arr,
                              # close the colored part with the reverse of $v
                              AngelPS1::Shell->ps1_invisible((!$v)->term);
                      }
                  } else {
                      # Expand the color
                      unshift @template, AngelPS1::Shell->ps1_invisible($v->term);
                  }
                  redo LOOP;
              } else {
                  if (wantarray) {
                      # Keep subs as they must be explicitely expanded using expand()
                      if ($r eq 'CODE') {
                          push @out, $v;
                          next LOOP;
                      # Array refs are only expanded after a chrome spec. See below
                      } elsif ($r eq 'ARRAY') {
                          push @out, [ reduce(@$v) ];
                          next LOOP;
                      }
                  }
                  warn "unexpected $r item in prompt\n";
                  next LOOP;
              }
          } else {
              # Skip if undef
              next unless defined $v;
  
              $v = AngelPS1::Shell->ps1_escape($v);
          }
          if (@out && ref($out[-1]) eq 'SCALAR') {
              ${$out[-1]} .= $v
          } else {  # CODE refs (and anything else) are preserved
              push @out, \$v;
          }
      }
      return @out if wantarray;
      return '' unless @out;
      die "invalid state after reduce: @out\n" if @out != 1 || ref $out[0] ne 'SCALAR';
      ${pop @out}
  }
  
  
  sub ps1_is_static
  {
      my $PS1 = shift;
      $#$PS1 == 0 && (ref $PS1->[0]) eq 'SCALAR'
  }
  
  
  '$';
ANGELPS1_COMPILER

$fatpacked{"AngelPS1/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN';
  use strict;
  use warnings;
  
  package AngelPS1::Plugin;
  
  
  '$';
ANGELPS1_PLUGIN

$fatpacked{"AngelPS1/Plugin/Battery.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN_BATTERY';
  
  use utf8;
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::Battery;
  
  our $VERSION = $AngelPS1::VERSION;
  
  use Exporter 5.57 'import';
  our @EXPORT = qw<BatteryPercent BatteryGauge>;
  
  use AngelPS1::Shell;
  use AngelPS1::System;
  use AngelPS1::Chrome qw<Red Green Blue Bold color>;
  
  our $SYMBOL_CHARGING = '⏚';
  our $SYMBOL_DISCHARGING = '⌁';
  
  sub BatteryPercent
  {
      my $fetch_battery_gen = AngelPS1::System->can('gen_fetch_battery')
  	or return;
      my $fetch_battery = $fetch_battery_gen->()
          or return;
  
      return sub {
  	my @status = $fetch_battery->();
  	return if !@status || $status[0] >= 0.80;
  	(
  	    (
  		$status[0] > 0.20
  		? Green
  		: Red
  	    ),
  	    [
  		sprintf '%s%d',
  		    ($status[1] ? $SYMBOL_CHARGING
  				: $SYMBOL_DISCHARGING),
  		    100 * $status[0]
  	    ]
  	)
      }
  }
  
  use constant {
      SYMBOL_CHARGING         => Blue + Bold,
      SYMBOL_DISCHARGING_HIGH => Green,
      SYMBOL_DISCHARGING_LOW  => Red,
      GAUGE_DISCHARGING_HIGH  => color(22) / color(235),  # Dark green over dark gray
      GAUGE_DISCHARGING_LOW   => color(22) / color(124),  # Dark green over dark red
      GAUGE_CHARGING_HIGH     => Blue / color(235) + Bold,  # Light blue over dark red
      GAUGE_CHARGING_LOW      => Blue / color(124) + Bold,  # Light blue over dark red
  };
  
  sub BatteryGauge
  {
      my $fetch_battery_gen = AngelPS1::System->can('gen_fetch_battery')
  	or return;
      my $fetch_battery = $fetch_battery_gen->()
          or return;
  
      require AngelPS1::Plugin::Gauges;
  
      return sub {
  	my @status = $fetch_battery->();
  	return if !@status || $status[0] >= 0.80;
          my $charging = $status[1];
          #$charging = 1;
  	my $high = $status[0] >= 0.3;
  	(
  	    ($charging ? (
                              SYMBOL_CHARGING, $SYMBOL_CHARGING,
                              $high ? GAUGE_CHARGING_HIGH : GAUGE_CHARGING_LOW,
                           )
  		       : (
                              $high ? SYMBOL_DISCHARGING_HIGH : SYMBOL_DISCHARGING_LOW, $SYMBOL_DISCHARGING,
                              $high ? GAUGE_DISCHARGING_HIGH : GAUGE_DISCHARGING_LOW,
                           )
              ),
  	    [
  		&AngelPS1::Plugin::Gauges::CharGauge($status[0])
  	    ],
  	)
      }
  }
  
  '$';
ANGELPS1_PLUGIN_BATTERY

$fatpacked{"AngelPS1/Plugin/DateTime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN_DATETIME';
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::DateTime;
  
  use Exporter 'import';
  our @EXPORT = qw< Time StrFTime >;
  
  sub Time ()
  {
      # FIXME this does not take in account if the user changes $ENV{TZ} in the
      # shell
      # TODO provoke an angel reload in that case
  
      sub { sprintf('%3$02d:%2$02d:%1$02d', localtime) }
  }
  
  sub StrFTime ($)
  {
      my $format = shift;
  
      require POSIX;
      sub { POSIX::strftime($format, localtime) }
  }
  
  '$'
ANGELPS1_PLUGIN_DATETIME

$fatpacked{"AngelPS1/Plugin/Gauges.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN_GAUGES';
  
  use utf8;
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::Gauges;
  
  our $VERSION = $AngelPS1::VERSION;
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw<
      CharGauge
      ColoredGauge
      StaticGauge
      DynamicGauge
  >;
  
  
  use constant GAUGE_VALUES => '_▁▂▃▄▅▆▇█';
  use constant GAUGE_COUNT => length(GAUGE_VALUES);
  
  
  sub CharGauge ($)
  {
      my $offset = int((shift)*GAUGE_COUNT);
      substr(GAUGE_VALUES, $offset, 1)
  }
  
  sub ColoredGauge ($$)
  {
      my $gauge = CharGauge(pop);
      return @_, [ $gauge ];
  }
  
  sub StaticGauge ($;$)
  {
      my $gauge = CharGauge(pop);
      return $gauge unless @_;
      return @_, [ $gauge ];
  }
  
  sub DynamicGauge ($;$)
  {
      goto &StaticGauge if (!ref $_[$#_]);
      my $generator = pop;
      if (@_) {
          return (@_, [ sub { CharGauge($generator->()) } ])
      } else {
          return sub { CharGauge($generator->()) }
      }
  }
  
  '$';
ANGELPS1_PLUGIN_GAUGES

$fatpacked{"AngelPS1/Plugin/Git.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN_GIT';
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::Git;
  
  use Exporter 5.57 'import';
  BEGIN {
      our $VERSION = $AngelPS1::VERSION;
      our @EXPORT = qw(GitInfo);
  }
  
  use AngelPS1::Util qw< which run one_line >;
  use AngelPS1::Chrome;
  
  my $git = eval { which 'git' };
  sub git
  {
      # All Git commands we call return a single line. We don't want '\n'
      one_line(run $git, @_)
  }
  
  sub GitInfo
  {
      unless ($git) {
          warn "'git' not found in PATH";
          return
      }
  
      # Cleanup the environment
      # This is done globally!
      delete @ENV{qw< GIT_DIR GIT_TRACE >};
  
      # Return a dynamic PS1 element
      sub {
          my $shell_state = shift;
  
          my $git_dir = $shell_state->{GIT_DIR};
          $git_dir = "$shell_state->{'PWD'}/.git" unless defined $git_dir;
          unless (-d $git_dir) {
              ($git_dir = git qw(rev-parse --git-dir))
                  or return;
          }
          # This seems to be incompatible with "git diff --shortstat"
          #local $ENV{'GIT_DIR'} = $git_dir;
  
          my @out;
          my $local_commits = 0;
  
          my $branch = git 'symbolic-ref', 'HEAD';
          if ($branch eq '') {
              ($branch = git 'rev-parse', '--short')
                  or return;
          } else {
              $branch =~ s{^refs/heads/}{};
  
              # Count the number of commits to push ($local_commits)
              if ((my $remote_branch = git qw(config --get), "branch.$branch.merge")
                  && (my $remote = git qw(config --get), "branch.$branch.remote")) {
  
                  # Compute the ref of our local image of the remote branch
                  (my $remote_branch_ref = $remote_branch) =~ s{^refs/heads/}{refs/remotes/$remote/};
  
                  # Count the commits
                  $local_commits =
                      git(qw(rev-list --no-merges --count),
                          "$remote_branch_ref..HEAD")
                      || 0;
              }
          }
  
          my $status = git qw(status --porcelain -z);
          my $untracked = $status =~ /(?:^|\0)\?\? /s;
  
          if ((my $shortstat = git qw(diff --shortstat)) && ($? >> 8) == 0) {
              my ($ins) = ($shortstat =~ /([0-9]+) insertions?\(/);
              my ($del) = ($shortstat =~ /([0-9]+) deletions?\(/);
  
              push @out,
                  Red, [ $branch ],
                  '(',
                      Magenta,
                      [ ($ins ? ("+$ins" . ($del ? "/" : '')) : '') . ($del ? "-$del" : '') ],
                      ($local_commits ? (',', Yellow, [ $local_commits ]) : ()),
                  ')';
          } elsif ($local_commits) {
              push @out,
                  Yellow, [ $branch ],
                  '(', Yellow, [ $local_commits ], ')';
          } else {
              push @out, Green, [ $branch ];
          }
  
          if (-f "$git_dir/refs/stash") {
              push @out, Red, [ '+' ];
          }
  
          if ($untracked) {
              push @out, Red, [ '*' ];
          }
  
          # TODO Git mark
  
          @out, ' '
      }
  }
  
  '$';
ANGELPS1_PLUGIN_GIT

$fatpacked{"AngelPS1/Plugin/Jobs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN_JOBS';
  use utf8;
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::Jobs;
  
  use AngelPS1;
  our $VERSION = $AngelPS1::VERSION;
  
  use Exporter 5.57 'import';
  our @EXPORT = qw<Jobs>;
  
  use AngelPS1::System;
  use AngelPS1::Chrome qw< Bold Yellow >;
  
  sub Jobs
  {
      my $count_jobs = AngelPS1::System->gen_count_jobs()
  	or return;
      my $theme = $_[0] || {};
      my $chrome_suspended_count = $theme->{suspended} || (Yellow+Bold);
      my @symbol_suspended = ( ($theme->{suspended_symbol} || Yellow), [ 'z' ] );
      my $chrome_background_count = $theme->{background} || (Yellow+Bold);
      my @symbol_background = ( ($theme->{background_symbol} || Yellow), [ '&' ] );
      my @separator = exists $theme->{separator}
  		  ? ( $theme->{separator}, [ '/' ])
  		  : ( '/' );
  
      return sub {
  	my ($suspended, $background) = $count_jobs->();
  	return if !defined($suspended) || $suspended+$background == 0;
  	my @res;
  	push @res, $chrome_suspended_count, [ $suspended ], @symbol_suspended
  	    if $suspended;
  	push @res, @separator if $suspended && $background;
  	push @res, $chrome_background_count, [ $background ], @symbol_background
  	    if $background;
  	@res
      }
  }
  
  1;
ANGELPS1_PLUGIN_JOBS

$fatpacked{"AngelPS1/Plugin/Layout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN_LAYOUT';
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::Layout;
  
  our $VERSION = $AngelPS1::VERSION;
  
  use Exporter 5.57 'import';
  our @EXPORT = qw(MarginLeft MarginRight);
  
  use AngelPS1::Compiler qw(expand);
  
  sub MarginLeft ($;$)
  {
      my $code = pop;
      if (!ref($code)) {
          return defined($code) && length($code) ? " $code" : ();
      }
      die 'MarginLeft: not a CODEREF' unless ref($code) eq 'CODE';
      my @margin = @_;
      @margin = (' ') unless @margin;
      sub {
          my @result = expand(@_, $code);
          return unless @result;
          (@margin, @result)
      }
  }
  
  sub MarginRight ($;$)
  {
      my $code = pop;
      if (!ref($code)) {
          return defined($code) && length($code) ? "$code " : ();
      }
      die 'MarginLeft: not a CODEREF' unless ref($code) eq 'CODE';
      my @margin = @_;
      @margin = (' ') unless @margin;
      sub {
          my @result = expand(@_, $code);
          return unless @result;
          (@result, @margin)
      }
  }
  
  '$';
ANGELPS1_PLUGIN_LAYOUT

$fatpacked{"AngelPS1/Plugin/LoadAvg.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN_LOADAVG';
  use utf8;
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::LoadAvg;
  
  our $VERSION = $AngelPS1::VERSION;
  
  use Exporter 5.57 'import';
  our @EXPORT = qw<LoadAvgPercent>;
  
  use AngelPS1;
  use AngelPS1::Shell;
  use AngelPS1::System;
  use AngelPS1::Chrome qw<Red Green Bold color>;
  
  our $SYMBOL_LOADAVG = '⌂';
  
  sub LoadAvgPercent
  {
      my $loadavg_gen = AngelPS1::System->can('gen_loadavg')
  	or return;
  
      # Plugin disabled if the encoding doesn't support the symbol
      AngelPS1::_str_allowed($SYMBOL_LOADAVG) or return;
  
      my $loadavg_func = $loadavg_gen->();
  
      return sub {
  	my $loadavg = $loadavg_func->();
  	return if !defined($loadavg);
  	(
  	    (
  		$loadavg < 0.80
  		? Green
  		: Red
  	    ),
  	    [
  		sprintf '%s%d',
  		    $SYMBOL_LOADAVG,
  		    100 * $loadavg,
  	    ]
  	)
      }
  }
  
  '$';
ANGELPS1_PLUGIN_LOADAVG

$fatpacked{"AngelPS1/Plugin/Term.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN_TERM';
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::Term;
  
  our $VERSION = $AngelPS1::VERSION;
  
  use Exporter 5.57 'import';
  our @EXPORT = qw(TermTitle);
  
  use AngelPS1::Shell;
  
  use constant {
      TITLE_BEGIN => "\e]0;",
      TITLE_END   => "\a",
  };
  
  sub TermTitle
  {
      if (AngelPS1::Shell->name eq 'fish') {
          require Carp;
          Carp::carp("TermTitle is not supported on fish. See instead fish_title in the fish manual http://fishshell.com/docs/2.0/index.html#title");
          return
      }
      # TODO use tsl/fsl from terminfo, if the terminfo definition has them
      # TODO Truncate to wsl
      # TODO check eslok and escape if necessary
      AngelPS1::Shell->ps1_invisible(TITLE_BEGIN, @_, TITLE_END)
  }
  
  '$';
ANGELPS1_PLUGIN_TERM

$fatpacked{"AngelPS1/Plugin/Term/Size.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN_TERM_SIZE';
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::Term::Size;
  
  use AngelPS1; # $AngelPS1::TTYNAME
  
  our $VERSION = $AngelPS1::VERSION;
  
  use Exporter 5.57 ();
  our @ISA = 'Exporter';
  our @EXPORT = qw($LINES $COLUMNS);
  
  our ($LINES, $COLUMNS);
  
  my $TIOCGWINSZ =
      # Shortcut static table
      {
          # $^O => ioctl TIOCGWINSZ constant
          linux => 0x5413,
      }->{$^O}
  ||
      # Fallback: get the constant from ioctl.ph
      eval {
          package AngelPS1::Plugin::Term::Size::ioctl;
          require 'sys/ioctl.ph';
          delete $INC{'sys/ioctl.ph'};
          \&TIOCGWINSZ
      };
  
  
  my $_WINSZ = pack('S4');
  
  sub _update_from_ioctl
  {
      ioctl(STDERR, $TIOCGWINSZ, $_WINSZ);
      ($LINES, $COLUMNS) = unpack('S2', $_WINSZ);
  }
  
  sub _update_from_stty
  {
      my $line = $^O eq 'linux'
          ? `stty -F "/dev/$AngelPS1::TTYNAME" size`
          # darwin, *BSD have '-f', Solaris has neither
          : `stty size <"/dev/$AngelPS1::TTYNAME"`;
      chomp($line);
      ($LINES, $COLUMNS) = split / /, $line;
  }
  
  
  
  sub import
  {
      # Avoid multiple install due to multiple import from different packages
      unless ($SIG{WINCH}) {
          if (defined $TIOCGWINSZ) {
              # Terminal size change
              $SIG{WINCH} = \&_update_from_ioctl;
          } else {
              $SIG{WINCH} = \&_update_from_stty;
          }
  
          # Fetch now
          $SIG{WINCH}->();
      }
  
      $_[0]->export_to_level(1, @_);
  }
  
  '$';
ANGELPS1_PLUGIN_TERM_SIZE

$fatpacked{"AngelPS1/Plugin/Term/screen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN_TERM_SCREEN';
  
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::Term::screen;
  
  our $VERSION = $AngelPS1::VERSION;
  
  use Exporter 5.57 ();
  our @ISA = 'Exporter';
  our @EXPORT = qw(ScreenTitle);
  
  use AngelPS1::Shell;
  
  sub ScreenTitle
  {
      return if $ENV{'TERM'} ne 'screen'
          || exists $ENV{'TMUX'}
          || !exists $ENV{'TERMCAP'};
  
      AngelPS1::Shell->ps1_invisible(
  	"\ek",
  	@_,
  	"\e\\"
      )
  }
  
  
  
  '$';
ANGELPS1_PLUGIN_TERM_SCREEN

$fatpacked{"AngelPS1/Plugin/Term/tmux.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN_TERM_TMUX';
  
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::Term::tmux;
  
  our $VERSION = $AngelPS1::VERSION;
  
  use Exporter 5.57 ();
  our @ISA = 'Exporter';
  our @EXPORT = qw(TmuxWindow TmuxTitle);
  
  use AngelPS1::Shell;
  
  sub TmuxWindow
  {
      return if !exists $ENV{'TMUX'}
          || $ENV{'TERM'} ne 'screen';
  
      AngelPS1::Shell->ps1_invisible(
  	"\ek",
  	@_,
  	"\e\\"
      )
  }
  
  sub TmuxTitle
  {
      return if !exists $ENV{'TMUX'}
          || $ENV{'TERM'} ne 'screen';
  
      AngelPS1::Shell->ps1_invisible(
  	"\e]2;",
  	@_,
  	"\e\\"
      )
  }
  
  '$';
ANGELPS1_PLUGIN_TERM_TMUX

$fatpacked{"AngelPS1/Plugin/VCS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PLUGIN_VCS';
  use strict;
  use warnings;
  
  package AngelPS1::Plugin::VCS;
  
  use Exporter 'import';
  our @EXPORT = qw<VCSInfo>;
  
  use constant NO_DIR_STAT => (stat '..')[3] < 3;
  
  sub _find_vcs_dir
  {
      my $dir = shift;
      return if $dir eq '/';
      my @stat = stat $dir;
      my $dev = $stat[0];
      # Look up while we are on the same filesystem
      while ($stat[0] == $dev) {
          if (NO_DIR_STAT || $stat[3] > 3) {
              return (git => $dir) if -d "$dir/.git/objects";
              return (svn => $dir) if -f "$dir/.svn/entries";
              return (hg  => $dir) if -d "$dir/.hg/store";
              return (bzr => $dir) if -d "$dir/.bzr";
              return ('git-bare' => $dir) if substr($dir, -4) eq '.git' && -d "$dir/objects"
          }
          # go up
          substr($dir, rindex($dir, '/'), length($dir), '');
          $dir or last;
          @stat = stat $dir;
      }
      return
  }
  
  my %VCS = (
      git => [
          'AngelPS1/Plugin/Git.pm',
          do {
              require AngelPS1::Plugin::Git;
              my @gitinfo = AngelPS1::Plugin::Git::GitInfo();
  
              sub {
                  my ($state, $dir) = @_;
                  return (
                      sub {
                          $state->{GIT_DIR} = $dir;
                          ()
                      },
                      @gitinfo,
                      sub {
                          delete $state->{GIT_DIR};
                          ()
                      },
                  )
              }
          }
      ],
  );
  
  sub VCSInfo
  {
      my $options = (@_ && ref($_[0]) eq 'HASH') ? (shift) : {};
      my @enabled_vcs = @_;
  
      sub {
          my $state = shift;
          my ($vcs, $dir) = _find_vcs_dir($state->{PWD});
          return unless defined $vcs;
          my $vcs_plugin = $VCS{$vcs};
          return unless defined $vcs_plugin;
  
          require $vcs_plugin->[0];
          return $vcs_plugin->[1]->($state, $dir)
      }
  }
  
  1;
ANGELPS1_PLUGIN_VCS

$fatpacked{"AngelPS1/Prompt/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PROMPT_DEFAULT';
  use strict;
  use warnings;
  
  package AngelPS1::Prompt::Default;
  
  use AngelPS1;
  use AngelPS1::Shell qw< WorkingDir_Tilde UserPrivSymbol >;
  use AngelPS1::Chrome;
  use AngelPS1::Plugin::Layout 'MarginRight';
  use AngelPS1::Plugin::DateTime;
  use AngelPS1::Plugin::Term;
  use AngelPS1::Plugin::Term::Size;
  use AngelPS1::Plugin::VCS;
  use AngelPS1::Plugin::Battery 'BatteryGauge';
  use AngelPS1::Plugin::LoadAvg 'LoadAvgPercent';
  use AngelPS1::Plugin::Jobs 'Jobs';
  
  use POSIX ();
  
  return () unless AngelPS1::Shell->can('WorkingDir_Tilde')
                && AngelPS1::Shell->can('UserPrivSymbol');
  
  (
      (
          # fish has its own special handling through the fish_title function
          AngelPS1::Shell->name eq 'fish'
          ? ()
          : TermTitle(
              (%AngelPS1::DEBUG
              ? (
                  AngelPS1::Shell->name,
                  ' ',
                  $AngelPS1::TTYNAME,
                  ' (',
                  # Columns and lines are dynamic!
                  sub { "${COLUMNS}x${LINES}) " },
              ) : ()),
              WorkingDir_Tilde,
          )
      ),
  
      # Disabled
      #Blue, [ Time ], ' ',
  
      MarginRight(' ', BatteryGauge),
      MarginRight(' ', LoadAvgPercent),
      MarginRight(' ', Jobs),
  
      # User name
      $< ? (scalar getpwuid $<) : (),
      sub { -w $_[0]->{PWD} ? Green : Red }, [ ':' ],
      WorkingDir_Tilde,
      ' ',
      VCSInfo,
      sub { my $err = $_[0]->{'?'}; $err == 0 ? () : (Red, [ $err ], ' ') },
      # User mark: root => #    else  $
      ($< ? (Bold, [ UserPrivSymbol ]) : (Red + Bold, [ '#' ])),
      ' ',
  )
ANGELPS1_PROMPT_DEFAULT

$fatpacked{"AngelPS1/Prompt/liquid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_PROMPT_LIQUID';
  use strict;
  use warnings;
  
  package AngelPS1::Prompt::liquid;
  
  sub _shell_unescape ($)
  {
      my $txt = shift;
  
      # This is a very simplistic implementation that
      # should be enough for liquidprompt configs
          $txt =~ s/^'(.*)'$/$1/
      or ($txt =~ s/^"(.*)"$/$1/ and $txt =~ s/\\./\\/g);
  
      $txt
  }
  
  sub read_rc
  {
      my $file = shift;
      open my $f, '<:encoding(UTF-8)', $file or die "Can't open $file: $!\n";
      my %conf =
          map { m/LP_(.*?)=(.*?)\s*$/ ? ($1 => _shell_unescape $2) : () }
          grep /LP_.*=/,
          grep !/^\s*(?:#|$)/,
          <$f>;
      close $f;
      \%conf
  }
  
  my $conf = read_rc "$ENV{HOME}/.liquidpromptrc";
  print STDERR "$_=$conf->{$_}\n" for keys %$conf;
  
  do 'AngelPS1/Prompt/Default.pm';
ANGELPS1_PROMPT_LIQUID

$fatpacked{"AngelPS1/Shell.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_SHELL';
  use strict;
  use warnings;
  
  package AngelPS1::Shell;
  
  my %ALIASES = (
      dash  => 'POSIX',
      ksh   => 'ksh93',
      # Not tested
      ksh88 => 'POSIX',
  );
  
  
  my $name;
  
  sub name
  {
      $name
  }
  
  sub import
  {
      return unless @_ > 1;
  
      no strict 'refs';
      shift;
      my $pkg = (caller)[0];
      my @subs = @_;
      foreach my $s (@subs) {
          my $proto;
          $s =~ s/(\(.*\))\z// and $proto = $1;
  
          if (defined $name && ! AngelPS1::Shell->can($s) ) {
              require Carp;
              Carp::croak("can't import '$s'");
          }
  
          *{"$pkg\::$s"} = sub { AngelPS1::Shell->$s(@_) };
      }
  }
  
  sub use
  {
      my ($class, $shell) = @_;
      if ($shell) {
          $shell = $ALIASES{$shell} if exists $ALIASES{$shell};
          my $src = "AngelPS1/Shell/$shell.pm";
          unless (exists $INC{$src}) {
              # TODO try to distinguish load errors (file not found) from compile errors
              # by pushing a sub on @INC that will be called.
              eval { require $src }
                  or die "$shell is not a supported shell: $@.\n";
          }
  
          # Make AngelPS1::Shell a sub class of the loaded module
          our @ISA = ("${class}::$shell");
          $name = $shell;
      }
  }
  
  
  sub detect
  {
      require AngelPS1;
      require AngelPS1::Util;
      # Extract the name of $PPID
  
      my $ppid = $AngelPS1::SHELL_PID;
      my $shell;
  
      GET_CMD: {
          # Linux/cygwin shortcut
          for my $comm_file ("/proc/$ppid/comm", "/proc/$ppid/cmdline") {
              next unless -f $comm_file && -r _;
              open my $comm, '<', $comm_file or next;
              $shell = <$comm>;
              $shell =~ s/\0.*$//s;  # /proc/*/cmdline under cygwin
              last GET_CMD if length $shell;
          }
          # Other platforms
          $shell = AngelPS1::Util::run(ps => qw(-o comm=), $ppid)
      }
      $shell = AngelPS1::Util::one_line($shell);
  
      # Keep only the basename
      $shell =~ s{^.*/}{};
  
      # Login shells may begin with a '-': '-bash'
      $shell =~ s/^-//;
  
      $shell
  }
  
  '$';
ANGELPS1_SHELL

$fatpacked{"AngelPS1/Shell/POSIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_SHELL_POSIX';
  use strict;
  use warnings;
  
  package AngelPS1::Shell::POSIX;
  
  sub ps1_escape
  {
      #(my $s = $_[1]) =~ s{([\\\$`])}{\\$1}gs;
      #$s
      $_[1]
  }
  
  sub ps1_invisible
  {
      shift; # $class
      @_
  }
  
  sub ps1_finalize
  {
      $_[1]
  }
  
  sub ps1_function_name
  {
      my $angel_name = $_[1];
      # dash, (should check for the real POSIX shell) doesn't like '-' in function
      # names. Is it related to its name?
      $angel_name =~ s/-/_/g;
      "_${angel_name}_PS1"
  }
  
  sub ps1_time_debug
  {
      # Not supported
      ''
  }
  
  sub shell_local
  {
      'local'
  }
  
  sub shell_code_dynamic
  {
      my ($class, %options) = @_;
      my ($DEBUG, $NAME, $IN, $OUT, $PID, $env) =
          @options{qw<debug name in out pid env>};
  
      my $function_name = $class->ps1_function_name($NAME);
      my $time_debug = $DEBUG->{'time'} ? $class->ps1_time_debug : '';
      my $argv = join(' ', map { (my $x=$_) =~ s/'/'\\''/g; qq<'$x'> } @AngelPS1::ARGV_BACKUP);
      my $local = $class->shell_local;
  
      # The shell code will be evaluated with eval as a single line
      # so statements must be properly terminated with ';'
      # No shell comments allowed
      # No unquoted wildcards (*, ?, []) allowed. See GH #17.
      <<EOF;
  [ -n "\$APS1_NAME" ] && \$APS1_NAME leave;
  APS1_PS1="\$PS1";
  $function_name()
  {
      $local err=\$?;
      [ -e '$IN' ] || { eval "echo '\$APS1_PS1'"; $NAME leave ; return ; };
      printf '%s\\0%s' "?=\$err" "PWD=\$PWD" > '$IN' || { eval "echo '\$APS1_PS1'"; $NAME leave ; return ; };
      cat $OUT || $NAME leave ;
  } ;
  PS1='\$($time_debug$function_name)' ;
  APS1_NAME=$NAME ;
  APS1_PID=$PID ;
  $NAME()
  {
      case "\$1" in
      reload)
          eval \$($0 $argv) ;;
      leave|quit|go-away)
          PS1="\$APS1_PS1" ;
          kill \$APS1_PID 2>/dev/null ;
          rm -f -- '$IN' '$OUT' ;
          unset APS1_PS1 APS1_PID APS1_NAME ;
          unset -f -- $NAME $function_name ;;
      mute|off)
          PS1="\$APS1_PS1" ;;
      unmute|on)
          PS1='\$($time_debug$function_name)' ;;
      ''*)
          echo 'usage: $NAME [reload|quit|mute|off|unmute|on]' >&2 ;
          return 1 ;;
      esac ;
  } ;
  trap 'command -v $NAME >/dev/null && $NAME leave' EXIT ;
  EOF
  }
  
  sub WorkingDir
  {
      sub {
          $_[0]->{'PWD'}
      }
  }
  
  sub WorkingDir_Tilde
  {
      my $home = $ENV{'HOME'};
      sub {
          my $pwd = $_[0]->{'PWD'};
          $pwd =~ s{^$home(/|$)}{~$1}s;
          $pwd
      }
  }
  
  sub Hostname
  {
      require Sys::Hostname;
      Sys::Hostname::hostname()
  }
  
  sub UserPrivSymbol
  {
      \( $< ? '$' : '#' )
  }
  
  '$';
ANGELPS1_SHELL_POSIX

$fatpacked{"AngelPS1/Shell/bash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_SHELL_BASH';
  use strict;
  use warnings;
  
  package AngelPS1::Shell::bash;
  
  
  sub ps1_escape
  {
      (my $s = $_[1]) =~ s{([\\\$`])}{\\$1}gs;
      $s =~ s{\n}{\\012}gs;
      $s
  }
  
  sub ps1_invisible
  {
      shift; # $class
      (\'\[', @_, \'\]')
  }
  
  
  sub ps1_finalize
  {
      # Escape the first and last space using bash PS1 encoding as 'read' removes spaces
      # at beginning and end of line
      (my $PS1 = $_[1]) =~ s/^ | $/\\040/g;
      # Escape \ as 'read' expands them
      $PS1 =~ s/\\/\\\\/g;
      # Escape newlines
      $PS1 =~ s/\n/\\\n/g;
      "$PS1\n"
  }
  
  sub shell_code_static
  {
      my ($class, $PS1, %options) = @_;
      qq{[[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave; PS1='$PS1'\n}
  }
  
  sub shell_code_dynamic
  {
      my ($class, %options) = @_;
      my ($DEBUG, $NAME, $IN, $OUT, $PID, $env) =
          @options{qw<debug name in out pid env>};
  
      my $shell_debug = $DEBUG->{'in'} ? q|printf 'DEBUG> PS1=%q\\n' "$PS1" ; | : '';
      my $time_debug = $DEBUG->{'time'} ? q|time | : '';
      my $script = eval { require FindBin; $FindBin::Bin.'/'.$FindBin::Script } || $0;
      my $reload = join(' ', map { (my $x=$_) =~ s/'/'\\''/g; qq<'$x'> }
                             $^X, $script, @AngelPS1::ARGV_BACKUP);
  
      # The shell code will be evaluated with eval as a single line
      # so statements must be properly terminated with ';'
      # No shell comments allowed
      # No unquoted wildcards (*, ?) allowed (see GH #17). That's why we
      # use the ''*)  trick in the 'case' block of the angel function.
      <<EOF;
  [[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave;
  APS1_PS1="\$PS1";
  APS1_PROMPT_COMMAND="\$PROMPT_COMMAND";
  -angel-PS1()
  {
      local err=\$?;
      [[ -e '$IN' ]] || { $NAME leave ; return ; };
      printf '%s\\0%s' "?=\$err" "PWD=\$PWD" > '$IN' || { $NAME leave ; return ; };
      read PS1 < '$OUT' || $NAME leave ;
      $shell_debug
  } ;
  PROMPT_COMMAND='${time_debug}-angel-PS1' ;
  APS1_NAME=$NAME ;
  APS1_PID=$PID ;
  $NAME()
  {
      case "\$1" in
      reload)
          eval \$($reload) ;;
      leave|quit|go-away)
          PROMPT_COMMAND="\$APS1_PROMPT_COMMAND" ;
          PS1="\$APS1_PS1" ;
          kill \$APS1_PID 2>/dev/null ;
          rm -f -- '$IN' '$OUT' ;
          unset APS1_PS1 APS1_PID APS1_NAME APS1_PROMPT_COMMAND ;
          [[ "\$(trap -p EXIT)" = "trap -- '$NAME leave' EXIT" ]] && trap - EXIT ;
          unset -f -- $NAME -angel-PS1 ;;
      mute|off)
          PROMPT_COMMAND="\$APS1_PROMPT_COMMAND" ;
          PS1="\$APS1_PS1" ;;
      unmute|on)
          PROMPT_COMMAND=-angel-PS1 ;;
      ''*)
          echo 'usage: $NAME [reload|quit|mute|off|unmute|on]' >&2 ;
          return 1 ;;
      esac ;
  } ;
  trap '$NAME leave' EXIT ;
  EOF
  
  }
  
  
  sub WorkingDir
  {
      \'$PWD'
  }
  
  sub WorkingDir_Tilde
  {
      \'\w'
  }
  
  sub Hostname
  {
      \'h'
  }
  
  sub UserPrivSymbol
  {
      \'\$'
  }
  
  '$';
ANGELPS1_SHELL_BASH

$fatpacked{"AngelPS1/Shell/fish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_SHELL_FISH';
  use strict;
  use warnings;
  
  package AngelPS1::Shell::fish;
  
  sub ps1_escape
  {
      # Do nothing
      $_[1]
  }
  
  sub ps1_invisible
  {
      shift; # $class
      # Do nothing
      @_
  }
  
  sub ps1_finalize
  {
      # Do nothing
      $_[1]
  }
  
  
  sub shell_code_dynamic
  {
      my ($class, %options) = @_;
      my ($DEBUG, $NAME, $IN, $OUT, $PID, $env) =
          @options{qw<debug name in out pid env>};
  
      # The shell code will be evaluated with eval as a single line
      # so statements must be properly terminated with ';'
      # No shell comments allowed
  
      #set err \$status;
      #if test ! -e '$IN'; $NAME leave; fish_prompt; return; end;
      #if ! printf '%s\\0%s' "?=\$err" "PWD=\$PWD" > '$IN'; $NAME leave; fish_prompt; return; end;
      <<EOF;
  if test -n "\$APS1_NAME"; eval \$APS1_NAME leave; end;
  set -g aps1_prompt_orig (functions fish_prompt | sed 's/#[^'\\''"]*\$//;s/\$/;/');
  function fish_prompt;
      set _err \$status;
      if test ! -e '$IN'; $NAME leave; fish_prompt; return; end;
      /usr/bin/printf '%s\\0%s' "?=\$_err" "PWD=\$PWD" > '$IN';
      cat '$OUT';
  end;
  set -g aps1_prompt (functions fish_prompt | sed '1s/fish_prompt/fish_prompt;/');
  function $NAME;
      switch "\$argv[1]";
      case quit;
          $NAME leave;
      case leave;
          kill \$APS1_PID 2>/dev/null;
          rm -f -- '$IN';
          set -e -g APS1_PID;
          set -e -g APS1_NAME;
          set -e -g aps1_prompt;
          functions -e fish_prompt $NAME $NAME-EXIT;
          complete -c $NAME -e;
          eval "\$aps1_prompt_orig";
          set -e -g aps1_prompt_orig;
      case mute;
          $NAME off;
      case off;
          eval "\$aps1_prompt_orig";
          complete -c $NAME -e;
          complete -c $NAME -A -f -a 'quit on';
      case unmute;
          $NAME on;
      case on;
          eval "\$aps1_prompt";
          complete -c $NAME -e;
          complete -c $NAME -A -f -a 'quit off';
      case '*';
          echo 'usage: $NAME [quit|mute|off|unmute|on]' >&2;
          return 1;
      end;
  end;
  function $NAME-EXIT --on-process %self;
      kill $PID;
  end;
  complete -c $NAME -A -f -a 'quit off';
  set -g APS1_PID $PID;
  set -g APS1_NAME '$NAME';
  EOF
  }
  
  sub WorkingDir
  {
      sub {
          $_[0]->{'PWD'}
      }
  }
  
  sub WorkingDir_Tilde
  {
      my $home = $ENV{'HOME'};
      sub {
          my $pwd = $_[0]->{'PWD'};
          $pwd =~ s{^$home(/|$)}{~$1}s;
          $pwd
      }
  }
  
  sub Hostname
  {
      require Sys::Hostname;
      Sys::Hostname::hostname()
  }
  
  sub UserPrivSymbol
  {
      \( $< ? '$' : '#' )
  }
  
  '$';
ANGELPS1_SHELL_FISH

$fatpacked{"AngelPS1/Shell/ksh93.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_SHELL_KSH93';
  use strict;
  use warnings;
  
  package AngelPS1::Shell::ksh93;
  
  use AngelPS1::Shell::POSIX ();
  our @ISA = ('AngelPS1::Shell::POSIX');
  
  
  sub ps1_finalize
  {
      (my $s = $_[1]) =~ s/!/!!/gs;
      $s
  }
  
  
  sub shell_local
  {
      'typeset'
  }
  
  
  
  sub ps1_time_debug
  {
      # Note that "time -- " doesn't work (/usr/bin/time is used in that case)
      q|time |;
  }
  
  sub shell_code_dynamic
  {
      my $class = shift;
      my $shell_code = $class->SUPER::shell_code_dynamic(@_);
      # Replace [ ... ] (external 'test' command) with [[ ... ]] (internal)
      $shell_code =~ s{([\[\]])}{$1$1}g;
      return $shell_code
  }
  
  '$';
ANGELPS1_SHELL_KSH93

$fatpacked{"AngelPS1/Shell/mksh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_SHELL_MKSH';
  use strict;
  use warnings;
  
  package AngelPS1::Shell::mksh;
  
  use AngelPS1::Shell::POSIX ();
  our @ISA = ('AngelPS1::Shell::POSIX');
  
  
  use constant INVIS_CHAR => "\x01";
  
  sub ps1_escape
  {
      (my $s = $_[1]) =~ s/!/!!/gs;
      $s =~ s{([\\\$`])}{\\$1}gs;
      # TODO remove INVIS_CHAR
      $s
  }
  
  sub ps1_invisible
  {
      return if @_ == 1;
      shift; # $class
      my $invis = INVIS_CHAR;
      return (\$invis, @_, \$invis)
  }
  
  sub ps1_finalize
  {
      my $PS1 = $_[1];
      if (index($PS1, INVIS_CHAR) >= 0) {
          # Remove useless leave/enter invisible mode
          my $inv = INVIS_CHAR;
          $PS1 =~ s/\Q$inv$inv//g;
          # Insert the special sequence that tells the invisible mode marker
          substr $PS1, 0, 0, INVIS_CHAR . "\r";
      }
      $PS1
  }
  
  sub ps1_function_name
  {
      '-angel-PS1'
  }
  
  sub ps1_time_debug
  {
      q|time -- |;
  }
  
  sub shell_code_dynamic
  {
      my $class = shift;
      my $shell_code = $class->SUPER::shell_code_dynamic(@_);
      # Replace [ ... ] (external 'test' command) with [[ ... ]] (internal)
      $shell_code =~ s{([\[\]])}{$1$1}g;
      return $shell_code
  }
  
  sub shell_code_static
  {
      my ($class, $PS1, %options) = @_;
      $PS1 = $class->ps1_finalize($PS1);
      pos($PS1) = 0;
      $PS1 =~ s/\G'/'\\''/g;
      # Preserve \n
      $PS1 =~ s/\n/'\$'\\n''/gs;
      $PS1 =~ s/\t/'\$'\\t''/gs;
      # Look at:
      #    echo $(echo "ab   cd")  ->  "ab cd"
      # We are in this case with < eval $(angel-PS1) > (without quotes)
      # so we replace consecutive spaces by an alternate representation
      $PS1 =~ s/  /'\\ \\ '/g;
      $PS1 = "'$PS1'";
      $PS1 =~ s/'''/'/g;
      $PS1 =~ s/^''|[^ ]''$//gs;
      qq{[[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave; PS1=$PS1\n}
  }
  
  '$';
ANGELPS1_SHELL_MKSH

$fatpacked{"AngelPS1/Shell/tcsh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_SHELL_TCSH';
  use strict;
  use warnings;
  
  package AngelPS1::Shell::tcsh;
  
  
  sub ps1_escape
  {
      # csh special symbols
      (my $s = $_[1]) =~ s{%}{%%}gs;
      # csh special sequences for special chars, à la bindkey
      $s =~ s{\\}{\\\\}gs;
      $s =~ s{\^}{\\136}gs;
      # csh special: history number
      $s =~ s{!}{\\041}gs;
      # \n must be escaped as tcsh replaces it with space in backquote (`) output
      $s =~ s{\n}{\\n}gs;
      #print STDERR "Escape [$_[1]] => [$s]\n";
      $s
  }
  
  sub ps1_invisible
  {
      shift; # $class
      (\'%{', @_, \'%}')
  }
  
  sub ps1_finalize
  {
      my $prompt = $_[1];
      $prompt =~ s/'/'\\''/g;
      # tcsh replaces '\n' with a space in command substitution (backquotes: `)
      # so '\n' will be lost in our current implementation
      # TODO: try to replace with '\\n'
      warn "Prompt has '\\n' This is not supported by angel-PS1!" if $prompt =~ /\n/;
      qq{set prompt = '$prompt'};
  }
  
  sub shell_code_dynamic
  {
      my ($class, %options) = @_;
      my ($DEBUG, $NAME, $IN, $OUT, $PID, $env) =
          @options{qw<debug name in out pid env>};
  
      # Reference for this csh shit:
      # - http://www.grymoire.com/Unix/CshTop10.txt
      # - http://www.faqs.org/faqs/unix-faq/shell/csh-whynot/
  
      # Note that because of bug http://bugs.gw.com/view.php?id=259
      # we can not use if/else/endif in aps1_precmd because that
      # pollutes the history, so we can't do check of existence of
      # $IN (see previous implementation in the history)
  
      my $shell_code = <<EOF;
  if ( \${?aps1_name} ) then
      eval \$aps1_name leave
  endif
  set aps1_prompt = \$prompt:q
  set aps1_precmd = 'set aps1_err = \$?\\
  if ( -p $IN ) then\\
      echo -n "?=\$aps1_err:q\\0PWD=\$PWD:q" > $IN\\
      eval "`cat $OUT`"\\
  endif'
  alias precmd 'eval \$aps1_precmd:q'
  alias $NAME 'switch ( \\!* )\\
      case leave:\\
      case quit:\\
          set prompt = "\$aps1_prompt:q"\\
          kill \$aps1_pid\\
          rm -f -- $IN $OUT\\
          unset aps1_prompt aps1_pid aps1_name aps1_precmd\\
          unalias precmd $NAME\\
          breaksw\\
      case off:\\
      case mute:\\
          unalias precmd\\
          set prompt = \$aps1_prompt:q\\
          breaksw\\
      case on:\\
      case unmute:\\
          alias precmd \$aps1_precmd:q\\
          :\\
          breaksw\\
      default:\\
          echo "$NAME: unknown option"\\
          echo "usage: $NAME [quit|mute|off|unmute|on]"\\
          breaksw\\
  endsw'
  set aps1_name = '$NAME'
  set aps1_pid = '$PID'
  EOF
  
      # Inside backquotes (`) output \n are replaced with spaces by tcsh
      # So switch/if can not work.
      # Workaround: save the shell code to a file, and source it.
      require POSIX;
      my $file = POSIX::tmpnam()."$$.tcsh";
      # TODO encoding, as the angel name may not be ascii
      open my $f, '>', $file;
      print $f $shell_code;
      close $f;
  
      # Return value, passed as the eval argument
      # aps1_pid assignment will be concatenated
      #"cat $file; " . # For debugging
      "source $file; rm -f $file"
  }
  
  sub WorkingDir
  {
      \'%/'
  }
  
  sub WorkingDir_Tilde
  {
      \'%~'
  }
  
  sub Hostname
  {
      \'%h'
  }
  
  sub UserPrivSymbol
  {
      # The 'promptchars' variable defines exactly what will be displayed
      \'%#'
  }
  
  '$';
ANGELPS1_SHELL_TCSH

$fatpacked{"AngelPS1/Shell/zsh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_SHELL_ZSH';
  use strict;
  use warnings;
  
  package AngelPS1::Shell::zsh;
  
  use AngelPS1::Shell::POSIX ();
  
  sub ps1_escape
  {
      (my $s = $_[1]) =~ s{%}{%%}gs;
      $s
  }
  
  sub ps1_invisible
  {
      shift; # $class
      (\'%{', @_, \'%}')
  }
  
  
  sub ps1_finalize
  {
      # Escape the first and last space using zsh PS1 zero-length code because
      # 'read' removes spaces at beginning and end of content
      (my $PS1 = $_[1]) =~ s/^ /%{%} /s;
      $PS1 =~ s/ $/ %{%}/s;
      "$PS1\001"
  }
  
  sub shell_code_static
  {
      my ($class, $PS1, %options) = @_;
      pos($PS1) = 0;
      $PS1 =~ s/\G'/'\\''/g;
      # Preserve \n
      $PS1 =~ s/\n/'\$'\\n''/gs;
      $PS1 =~ s/\t/'\$'\\t''/gs;
      # Look at:
      #    echo $(echo "ab   cd")  ->  "ab cd"
      # We are in this case with < eval $(angel-PS1) > (without quotes)
      # so we replace consecutive spaces by an alternate representation
      $PS1 =~ s/  /'\\ \\ '/g;
      $PS1 = "'$PS1'";
      $PS1 =~ s/'''/'/g;
      $PS1 =~ s/^''|[^ ]''$//gs;
      qq{[[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave; [[ -n "\$prompt_theme" ]] && prompt off ; set -o promptpercent; set -o nopromptbang; set -o nopromptsubst; PS1=$PS1\n}
  }
  
  sub shell_code_dynamic
  {
      my ($class, %options) = @_;
      my ($DEBUG, $NAME, $IN, $OUT, $PID, $env) =
          @options{qw<debug name in out pid env>};
  
      my $shell_debug = $DEBUG->{'in'} ? q|printf 'DEBUG> PS1=%q\\n' "$PS1" ; | : '';
      my $argv = join(' ', map { (my $x=$_) =~ s/'/'\\''/g; qq<'$x'> } @AngelPS1::ARGV_BACKUP);
  
      # The shell code will be evaluated with eval as a single line
      # so statements must be properly terminated with ';'
      # No shell comments allowed
      # Consecutives raw spaces will be reduced to one
      <<EOF;
  [[ -n "\$APS1_NAME" ]] && \$APS1_NAME leave;
  APS1_PS1="\$PS1";
  [[ -n "\$prompt_theme" ]] && { APS1_prompt="prompt '\$prompt_theme'"; prompt off; };
  -angel-PS1()
  {
      local err=\$?;
      [[ -e '$IN' ]] || { $NAME leave ; return ; };
      printf '%s\\0%s' "?=\$err" "PWD=\$PWD" > '$IN' || { $NAME leave ; return ; };
      read -rd\001 PS1 < '$OUT' || $NAME leave ;
      $shell_debug
  } ;
  set -o promptpercent ;
  set -o nopromptbang ;
  set -o nopromptsubst ;
  autoload -Uz add-zsh-hook ;
  add-zsh-hook precmd -angel-PS1 ;
  APS1_NAME=$NAME ;
  APS1_PID=$PID ;
  $NAME()
  {
      case "\$1" in
      reload)
          eval \$($0 $argv) ;;
      leave|quit|go-away)
          PS1="\$APS1_PS1" ;
          eval \$APS1_prompt ;
          kill \$APS1_PID 2>/dev/null ;
          rm -f -- '$IN' '$OUT' ;
          unset APS1_PS1 APS1_PID APS1_NAME APS1_prompt ;
          add-zsh-hook -d precmd -angel-PS1 ;
          add-zsh-hook -d zshexit -angel-PS1-exit ;
          unset -f -- $NAME -angel-PS1 -angel-PS1-exit ;;
      mute|off)
          add-zsh-hook -d precmd -angel-PS1 ;
          PS1="\$APS1_PS1" ;;
      unmute|on)
          add-zsh-hook precmd -angel-PS1 ;;
      ''*)
          echo 'usage: $NAME [reload|quit|mute|off|unmute|on]' >&2 ;
          return 1 ;;
      esac ;
  } ;
  -angel-PS1-exit() { $NAME leave ; } ;
  add-zsh-hook zshexit -angel-PS1-exit ;
  EOF
  
  }
  
  
  sub WorkingDir
  {
      \'%d'
  }
  
  sub WorkingDir_Tilde
  {
      \'%~'
  }
  
  
  sub Hostname
  {
      \'%m'
  }
  
  sub UserPrivSymbol
  {
      $< ? '$' : '#'
  }
  
  '$';
ANGELPS1_SHELL_ZSH

$fatpacked{"AngelPS1/System.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_SYSTEM';
  use strict;
  use warnings;
  
  package AngelPS1::System;
  
  my %ALIASES = (
      cygwin => 'linux',
  );
  
  my $name;
  
  sub name
  {
      $name
  }
  
  sub use
  {
      return if defined $name && @_ < 2;
      my ($class, $system) = @_;
      $system ||= $^O;
  
      $system = $ALIASES{$system} if exists $ALIASES{$system};
      my $src = "AngelPS1/System/$system.pm";
      require $src;
      our @ISA = ("${class}::$system");
      $name = $system;
  }
  
  *import = *use;
  
  
  sub gen_count_jobs
  {
      my $self = shift;
      require AngelPS1;
      my $PPID = shift || $AngelPS1::SHELL_PID;
      my $TTY  = shift || $AngelPS1::TTYNAME;
  
      # Try all implementations available on this system
      for my $gen_impl ($self->_count_jobs_impl) {
          # Call the generator to get an implementation
          my $sub = $self->$gen_impl($PPID, $TTY)
              or next;
          # Try it once
          my @result = $sub->();
          # Every check ok? We got the one!
          return $sub if @result;
      }
  
      # None works :(
      #warn "No count_jobs implementation!";
      undef
  }
  
  sub _count_jobs_impl
  {
      my $self = shift;
      # _gen_count_jobs can be implemented by an OS specific module
      # _gen_count_jobs_ps is the default, portable (?) implementation
      map { $self->can($_) || () } qw< _gen_count_jobs _gen_count_jobs_ps >
  }
  
  sub _gen_count_jobs_ps
  {
      my (undef, $PPID, $ttyname) = @_;
      #die unless $PPID;
      #die unless $ttyname;
  
      # We use a ps filter to avoid processing the whole table ourself
      # The filter must not hide process owned by other users.
      # This is the trickiest part because ps flags are not portable.
      my @ps_filter;
      TRY: {
          #chomp(my $sid = `ps -o sid= $$`);
          for my $try (
              [ '--ppid' => $PPID ],  # select by ppid (Linux)
              [ -t => $ttyname ],   # select by tty  (BSD, Linux)
              #[ -g => $sid ],      # select by sid  (Linux)
          ) {
              #warn "ps @$try >/dev/null 2>&1";
              system("ps @$try >/dev/null 2>&1") >> 8
                  and next;
              # Success
              @ps_filter = @$try;
              last TRY
          }
          # All tries failed :(
          return
      }
  
      my $regex = qr/^ *$PPID +([0-9]+) +(?:\1) +(.)/;
      sub {
          my ($suspended, $background) = (0, 0);
  
          $? = -1;
          open my $ps, "ps -o ppid= -o pgid= -o pid= -o stat= @ps_filter |"
              or return;
          # Check the return code if ever it is already finished
          return if $? >= 256;
  
          while (my $line = <$ps>) {
              #warn $_;
              next if $line !~ /$regex/ || $1 == $PPID;
              if ($2 eq 'T') {
                  $suspended++;
              } else {
                  $background++;
              }
          }
          close $ps;
          ($suspended, $background)
      }
  }
  
  
  '$';
ANGELPS1_SYSTEM

$fatpacked{"AngelPS1/System/darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_SYSTEM_DARWIN';
  use strict;
  use warnings;
  
  package AngelPS1::System::darwin;
  
  sub nproc
  {
      chomp(my $ncpu = `sysctl -n hw.ncpu`);
      $ncpu
  }
  
  sub gen_loadavg
  {
      sub {
          my $uptime = `uptime`;
          $uptime =~ /load averages: ([0-9]+\.[0-9]+) /;
          $1
      }
  }
  
  sub gen_fetch_battery
  {
      # Count lines of pmset -g batt
      my $lines_count =( )= `pmset -g batt`;
      return if $?;
  
      # "Now drawing from 'AC Power'" and no battery info
      return if $lines_count == 1;
  
      # FIXME handle "Battery Warning: Early"
      if ($lines_count > 2) {
          warn "only one battery supported. Patch welcome!"
      }
  
      return sub {
          my $pmset_batt = `pmset -g batt`;
  
          # 37%; AC attached; not charging
          # 8%; charging; 2:46 remaining
          # 9%; discharging; (no estimate)
          # 7%; discharging; 0:13 remaining
          $pmset_batt =~ m/\t([0-9]+)%;.* (dis)?charging/;
          my $level = $1 / 100;
          my $charging = ! defined $2;
  
          return ($level, $charging);
      }
  }
  
  '$';
ANGELPS1_SYSTEM_DARWIN

$fatpacked{"AngelPS1/System/linux.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_SYSTEM_LINUX';
  use strict;
  use warnings;
  
  package AngelPS1::System::linux;
  
  sub nproc
  {
      # Alternative: grep '^processor\t' /proc/cpuinfo
  
      my $nproc = `nproc`;
      return if $? < 0;
      return if $? & 127;
      chomp $nproc;
      $nproc
  }
  
  sub gen_loadavg
  {
      sub {
          open my $proc_loadavg, '<', '/proc/loadavg' or die;
          my $loadavg = readline $proc_loadavg;
          substr($loadavg, index($loadavg, ' '), length $loadavg, '');
          $loadavg
      }
  }
  
  sub _slurp_line
  {
      open my $f, '<', $_[0]
          or return;
      my $line = readline $f;
      chomp $line;
      $line
  }
  
  sub gen_fetch_battery
  {
      # List devices
      opendir my $power_devices, '/sys/class/power_supply'
          or return;
      my @batteries =
          map { "/sys/class/power_supply/$_" }
          grep { index($_, 'BAT') == 0 }
          readdir $power_devices;
      close $power_devices;
      return unless @batteries;
      if (@batteries != 1) {
          warn "only one battery supported. Patch welcome!"
      }
      my $bat = shift @batteries;
  
      # Sub that will query the battery status
      if (-f "$bat/capacity") {
          return sub {
              defined(my $capacity = _slurp_line "$bat/capacity") or return;
              defined(my $status = _slurp_line "$bat/status") or return;
              # 'Charging', 'Discharging', 'Full'
              return ($capacity / 100, $status ne 'Discharging');
          }
      }
      return sub {
          defined(my $charge_full = _slurp_line "$bat/charge_full") or return;
          defined(my $charge_now = _slurp_line "$bat/charge_now") or return;
          defined(my $status = _slurp_line "$bat/status") or return;
          # 'Charging', 'Discharging', 'Full'
          return ($charge_now / $charge_full, $status ne 'Discharging');
      }
  }
  
  sub _gen_count_jobs {
      my $PPID = $_[1];
  
      return unless -r "/proc/$PPID/stat";
  
      sub {
          opendir my $proc_dir, '/proc' or die "/proc: $!";
  
          my ($suspended, $background) = (0, 0);
  
          for my $pid ((readdir $proc_dir)) {
              next if $pid !~ /^[1-9]/;
              # Skip ourself
              next if $pid == $$;
              -r "/proc/$pid/stat" or next;
              open my $f, '<:raw', "/proc/$pid/stat" or next;
              # TODO rewrite read with sysread
              # FIXME read the whole file not just the first line
              # because $comm may contain "\n"
              my $stat = <$f>;
              close $f;
              my ($comm, $state, $ppid, $pgrp, $sid) = $stat =~ /\((.*)\) (.) (-?[0-9]+) (-?[0-9]+) (-?[0-9]+) / or die $stat;
              # Only childs of the shell
              next if $ppid ne $PPID;
              #printf "# %5d %5d %5d %5d %s %s\n", $pid, $ppid, $pgrp, $sid, $state, $comm;
              die $stat unless defined $pgrp;
              # Only process group leaders
              next if $pgrp ne $pid;
              if ($state eq 'T') {
                  $suspended++
              } else {
                  $background++;
              }
              #printf "%4d %s %s\n", $pid, $state, $comm;
          }
  
          close $proc_dir;
  
          return ($suspended, $background)
      }
  }
  
  
  
  '$';
ANGELPS1_SYSTEM_LINUX

$fatpacked{"AngelPS1/TermInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_TERMINFO';
  use strict;
  use warnings;
  
  package AngelPS1::TermInfo;
  
  use Exporter 'import';
  our @EXPORT_OK = qw<terminfo setaf>;
  
  use AngelPS1::Util 'run';
  
  sub terminfo ($;@); # Pre-declare for recursion
  
  my %terminfo_cache;
  
  sub terminfo ($;@)
  {
      my ($capability, @args) = @_;
      if (ref $capability) {
          my $cap0 = $capability->[0];
          if (exists $terminfo_cache{"\0$cap0"}) {
              $capability = $terminfo_cache{"\0$cap0"}
          } else {
              for my $cap (@$capability) {
                  my $res = terminfo $cap, @args;
                  next if $res eq '';
                  $terminfo_cache{"\0$cap0"} = $cap if $cap ne $cap0;
                  return $res
              }
              return '';
          }
      }
  
      my $query = join("\0", $capability, @args);
      return $terminfo_cache{$query} if exists $terminfo_cache{$query};
  
      my $result = run(tput => $capability, @args);
  
      # Cache the result
      $terminfo_cache{$query} = $result;
  
      $result
  }
  
  sub setaf ($) { terminfo [ qw(setaf AF) ], $_[0] }
  
  
  1;
ANGELPS1_TERMINFO

$fatpacked{"AngelPS1/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANGELPS1_UTIL';
  use strict;
  use warnings;
  
  package AngelPS1::Util;
  
  use Exporter 'import';
  our @EXPORT_OK = qw<which run one_line>;
  
  use IPC::Open3 ();
  use Symbol 'gensym';
  
  
  {
      my @PATH;
      BEGIN { @PATH = split /:/, $ENV{'PATH'}; }
      my %which;
  
      sub which ($)
      {
          my ($name, $no_cache) = @_;
  
          # Use the cache
          return $which{$name} if exists $which{$name};
          # Already a path with a directory?
          return $name if index($name, '/') >= 0;
  
          # Search in $PATH
          foreach my $p (@PATH) {
              my $f = "$p/$name";
              if (-x $f && ! -d _) {
                  $which{$name} = $f unless $no_cache;
                  return $f;
              }
          }
          die "$name: not found";
      }
  }
  
  sub run
  {
      my $command = which(shift);
      my ($in, $out);
      my $err = gensym;
      my $pid = IPC::Open3::open3(
          $in,
          $out,
          $err,
          $command,
          @_
      );
      my $result = do { local $/; readline $out };
      # TODO UTF-8 decoding
      waitpid($pid, 0);
      return $result
  }
  
  sub one_line
  {
      chomp(my $result = shift);
      $result
  }
  
  '$';
ANGELPS1_UTIL

$fatpacked{"Term/Chrome.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_CHROME';
  use strict;
  use warnings;
  
  package Term::Chrome;
  # ABSTRACT: DSL for colors and other terminal chrome
  our $VERSION = '2.00';
  
  # Pre-declare packages
  {
      package # no index: private package
          Term::Chrome::Color;
  }
  
  
  use Exporter 5.57 'import';  # perl 5.8.3
  # @EXPORT is defined at the end
  
  use Carp ();
  use Scalar::Util ();
  our @CARP_NOT = qw< Term::Chrome::Color >;
  
  # Private constructor for Term::Chrome objects. Lexical, so cross-packages.
  # Arguments:
  # - class name
  # - foreground color
  # - background color
  # - flags list
  my $new = sub
  {
      my ($class, @self) = @_;
  
      my $fg = $self[0];
      Carp::croak "invalid fg color $fg"
          if defined($fg) && ($fg < 0 || $fg > 255);
      my $bg = $self[1];
      Carp::croak "invalid bg color $bg"
          if defined($bg) && ($bg < 0 || $bg > 255);
      # TODO check flags
  
      bless \@self, $class
  };
  
  
  # Cache for color objects
  my %COLOR_CACHE;
  
  sub color ($)
  {
      my $color = shift;
      die "invalid color" if ref $color;
      my $c = chr $color;
      # We can not use '$COLOR_CACHE{$c} ||= ...' because this requires overloading
      # We can not use 'no overloading' because this requires perl 5.10
      exists $COLOR_CACHE{$c}
      ?  $COLOR_CACHE{$c}
      : ($COLOR_CACHE{$c} = Term::Chrome::Color->$new($color, undef))
  }
  
  
  use overload
      '""' => 'term',
      '+'  => '_plus',
      '${}' => '_deref',
      '&{}' => '_chromizer',
      '.'   => '_concat',
      '!'   => '_reverse',
      'bool' => sub () { 1 },
      fallback => 0,
  ;
  
  sub term
  {
      my $self = shift;
      my ($fg, $bg) = @{$self}[0, 1];
      my $r = join(';', @{$self}[2 .. $#$self]);
      if (defined($fg) || defined($bg)) {
          $r .= ';' if @$self > 2;
          if (defined $fg) {
              # LeoNerd says that this should be ----------> "38:5:$fg"
              # according to the spec but gnome-terminal doesn't support that
              $r .= $fg < 8 ? (30+$fg) : $fg < 16 ? "9$fg" : "38;5;$fg";
              $r .= ';' if defined $bg;
          }
          #                                      -------> "48:5:$bg"
          $r .= $bg < 8 ? (40+$bg) : $bg < 16 ? "10$bg" : "48;5;$bg" if defined $bg;
      } else {
          return '' unless @$self > 2
      }
      "\e[${r}m"
  }
  
  
  sub _plus
  {
      my ($self, $other, $swap) = @_;
  
      return $self unless defined $other;
  
      die 'invalid value for +' unless $other->isa(__PACKAGE__);
  
      my @new = @$self;
      $new[0] = $other->[0] if defined $other->[0];
      $new[1] = $other->[1] if defined $other->[1];
      push @new, @{$other}[2 .. $#$other];
  
      bless \@new
  }
  
  sub _reverse
  {
      my $self = shift;
      my @new = (undef, undef);
      push @new, 39 if $self->[0]; # ResetFg
      push @new, 49 if $self->[1]; # ResetBg
      # Reset/ResetFlags/ResetFg/ResetBg are removed
      # Other flags are reversed
      push @new, map { (!$_ || $_ == 22 || $_ > 30) ? () : ($_ > 20 ? $_-20 : $_+20) } @{$self}[2..$#$self];
      bless \@new, 'Term::Chrome::Flag'
  }
  
  sub _deref
  {
      \("$_[0]")
  }
  
  sub _concat
  {
      $_[2] ? $_[1].$_[0]->term
            : $_[0]->term.$_[1]
  }
  
  
  sub _chromizer
  {
      my $self = shift;
      my $begin = $self->term;
      my $end = $self->_reverse->term;
      sub {
          unless (defined $_[0]) {
              Carp::carp "missing argument in Term::Chrome chromizer";
              return
          }
          $begin . $_[0] . $end
      }
  }
  
  sub fg
  {
      my $c = $_[0]->[0];
      defined($c) ? color($c) : undef
  }
  
  sub bg
  {
      my $c = $_[0]->[1];
      defined($c) ? color($c) : undef
  }
  
  sub flags
  {
      my $self = shift;
      return undef unless @$self > 2;
      __PACKAGE__->$new(undef, undef, @{$self}[2..$#$self])
  }
  
  package # no index: private package
      Term::Chrome::Color;
  
  our @ISA = qw< Term::Chrome >;
  
  use overload
      '/'   => '_over',
      # Even if overloading is set in the super class, we have to repeat it for old perls
      (
          $^V ge v5.18.0
          ? ()
          : (
              '""'  => \&Term::Chrome::term,
              '+'   => \&Term::Chrome::_plus,
              '${}' => \&Term::Chrome::_deref,
              '.'   => \&Term::Chrome::_concat,
              '!'   => \&Term::Chrome::_reverse,
              'bool' => sub () { 1 },
          )
      ),
      fallback => 0,
  ;
  
  sub _over
  {
      die 'invalid bg color for /' unless ref($_[1]) eq __PACKAGE__;
      Term::Chrome->$new($_[0]->[0], $_[1]->[0])
  }
  
  package # no index: private package
      Term::Chrome::Flag;
  
  our @ISA = qw< Term::Chrome >;
  
  use overload
      '+'   => '_plus',
      '!'   => '_reverse',
      # Even if overloading is set in the super class, we have to repeat it for old perls
      (
          $^V ge v5.18.0
          ? ()
          : (
              '""'  => \&Term::Chrome::term,
              '${}' => \&Term::Chrome::_deref,
              '.'   => \&Term::Chrome::_concat,
              'bool' => sub () { 1 },
          )
      ),
      fallback => 0,
  ;
  
  sub _reverse
  {
      my $self = shift;
      bless [
          undef, undef,
          # Reset/ResetFlags/ResetFg/ResetBg are removed
          map { (!$_ || $_ == 22 || $_ > 30) ? () : ($_ > 20 ? $_-20 : $_+20) } @{$self}[2..$#$self]
      ]
  }
  
  sub _plus
  {
      my ($self, $other, $swap) = @_;
  
      return $self unless defined $other;
  
      Carp::croak(q{Can't combine Term::Chrome with }.$other)
          unless Scalar::Util::blessed $other;
  
      if ($other->isa(__PACKAGE__)) {
          # Reset
          return $other if !$other->[2];
          # ResetFlags
          return $other if $other->[2] == 22;
          # Concat flags
          __PACKAGE__->$new(@$self, @{$other}[2..$#$other])
      } elsif ($other->isa(Term::Chrome::)) {
          $other->_plus($self, '')
      } else {
          Carp::croak(q{Can't combine Term::Chrome with }.ref($other))
      }
  }
  
  
  package
      Term::Chrome;
  
  # Build the constants and the @EXPORT list
  #
  # This block must be after "use overload" (for both Term::Chrome
  # and Term::Chrome::Color) because overload must be set before blessing
  # due to a bug in perl < 5.18
  # (according to a comment in Types::Serialiser source)
  
  my $mk_flag = sub { Term::Chrome::Flag->$new(undef, undef, $_[0]) };
  
  my %const = (
      Reset      => $mk_flag->(''),
      ResetFg    => $mk_flag->(39),
      ResetBg    => $mk_flag->(49),
      ResetFlags => $mk_flag->(22),
      Standout   => $mk_flag->(7),
      Underline  => $mk_flag->(4),
      Reverse    => $mk_flag->(7),
      Blink      => $mk_flag->(5),
      Bold       => $mk_flag->(1),
  
      Black      => color 0,
      Red        => color 1,
      Green      => color 2,
      Yellow     => color 3,
      Blue       => color 4,
      Magenta    => color 5,
      Cyan       => color 6,
      White      => color 7,
  
      # Larry Wall's favorite color
      # The true 'chartreuse' color from X11 colors is #7fff00
      # The xterm-256 color #118 is near: #87ff00
      Chartreuse => color 118,
  );
  
  our @EXPORT = ('color', keys %const);
  
  # In 17fd029f we avoided to use constant.pm on perl < 5.16
  # This does not seem necessary anymore.
  require constant;
  constant->import(\%const);
  
  1;
  # vim:set et ts=8 sw=4 sts=4:
TERM_CHROME

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use utf8;

#    Copyright © 2013-2016 Olivier Mengué
#    Original source code is available at https://github.com/dolmen/angel-PS1
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.



use 5.008003;  # 5.010 is the sane minimum
use strict;
use warnings;

use AngelPS1; # Load globals ($VERSION, $VERBOSE...)

package AngelPS1;

use Getopt::Long qw(:config posix_default no_ignore_case auto_help);
use POSIX ();
use Encode ();
use FindBin;

# TODO ./dist should inline those modules
use AngelPS1::Shell ();
use AngelPS1::Compiler;
use AngelPS1::Chrome qw<Red Yellow Bold Reset>;

# http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
use lib (exists $ENV{XDG_CONFIG_HOME} ? "$ENV{XDG_CONFIG_HOME}/angel-PS1" : "$ENV{HOME}/.config/angel-PS1"),
        '/etc/xdg/angel-PS1';


# Extract encoding name from the locale
our $ENCODING = do {
    # Shortcut for the most common case
    my $locale = $ENV{LC_ALL} || $ENV{LC_CTYPE} || $ENV{LANG} || 'POSIX';
    $locale =~ /\.UTF-?8(?:@.*)?$/i
        ? 'UTF-8'
        : do {
            # warn "slow locale lookup...";
            POSIX::setlocale(POSIX::LC_CTYPE(), '');
            require I18N::Langinfo;
            eval { I18N::Langinfo::langinfo(I18N::Langinfo::CODESET()) }
                or do { warn $@; undef }
        }
};

# Decode @ARGV and encode STDOUT, STDERR
if ($ENCODING) {
    my $encoding_obj = Encode::find_encoding($ENCODING);
    map { $_ = $encoding_obj->decode($_) } @ARGV;
    binmode(STDOUT, ":encoding($ENCODING)");
    binmode(STDERR, ":encoding($ENCODING)");
}

# Preserve a copy of @ARGV
our @ARGV_BACKUP = @ARGV;

our $APP = !defined scalar caller;  # Running as command or include
$main::VERSION = our $VERSION if $APP;

our %DEBUG;
# Initialize from $ENV{APS1_DEBUG}
BEGIN {
    my @DEBUG_DEFAULTS = qw< in time >;

    sub _DEBUG
    {
        # $value is in $_[1] (instead of $_[0]) to be compatible with GetOptions
        # callback
        my $value = $_[1];
        if ($value eq '' || $value eq '1') {
            $DEBUG{$_} = 1 for @DEBUG_DEFAULTS
        } else {
            my @debug = split /,/, $value;
            splice(@debug, 0, 1, @DEBUG_DEFAULTS) if $debug[0] eq '';
            $DEBUG{$_} = 1 for @debug
        }
    }

    _DEBUG(undef, $ENV{APS1_DEBUG})
        if defined $ENV{APS1_DEBUG} && length $ENV{APS1_DEBUG};
}

my $shell;
our $NAME;    # Initialized in AngelPS1.pm
our $VERBOSE; # Initialized in AngelPS1.pm
my ($CONFIG, $PROMPT);
my $RUN_TEST;



$SIG{__DIE__} = sub {
    return if $^S;
    if (-t STDERR) {
        my $last = pop @_;
        $last =~ s/(\n)$//s;
        die((Red+Reset)->term, "$FindBin::Script: ", @_, $last, Reset->term, ($1 ? ($1) : ()));
    } else {
        die "$FindBin::Script: ", @_;
    }
};

if (-t STDERR) {
    my $YellowBold = (Yellow+Bold)->term;
    my $Reset = Reset->term;
    $SIG{__WARN__} = sub {
        my $last = pop;
        $last =~ s/(\n)$//s;
        warn $YellowBold, @_, $last, $Reset, ($1 ? ($1) : ());
    };
}



my @INCLUDES;

GetOptions(
    'version' => sub { print "angel-PS1 $VERSION\n"; exit 0 },
    'test+'    => \$RUN_TEST,
    'shell=s' => \$shell,
    'name=s' => \$NAME,
    'c|config=s' => \$CONFIG,
    'p|prompt=s' => \$PROMPT,
    'v|verbose' => \$VERBOSE,
    'q|quiet' => sub { $VERBOSE = -1 },
    'debug:s'  => \&_DEBUG,
    'I=s' => \@INCLUDES,
);

# Order is important: preserve the order as perl itself
lib->import(@INCLUDES);
undef @INCLUDES;

$shell = AngelPS1::Shell->detect unless defined $shell;
# Dynamically load our shell plugin
AngelPS1::Shell->use($shell);

# The angel name must be a valid shell function identifier
# Note that '-' is allowed, even as a first char
$NAME =~ /^[-A-Z_][-A-Z_0-9]*$/si or die "invalid angel name";



my @PS1;

# Load the configuration from @INC
{
    my @configs;

    if (defined $PROMPT) {
        (my $mod = "AngelPS1/Prompt/$PROMPT.pm") =~ s{::}{/};
        push @configs, $mod, "$PROMPT.PS1";
    } elsif ($CONFIG) {
        push @configs, $CONFIG;
    } else {
        # Usually: $HOME/.config/angel-PS1/angel.PS1
        push @configs, "AngelPS1/Prompt/$NAME.pm", "$NAME.PS1", 'AngelPS1/Prompt/Default.pm';
    }

    undef $CONFIG;
    foreach my $config (@configs) {
        undef $!;
        @PS1 = do { package AngelPS1::Prompt; do $config };
        die "load error: $@" if $@;
        unless ($!) {
            # Break if loading is ok
            $CONFIG = ref($INC{$config}) ? $config : $INC{$config};
            last;
        }
        warn "$config load error: $!" if $! && $DEBUG{config};
        $CONFIG = $config;
    }
    die "$CONFIG load error: $!" if $!;
}

die "invalid prompt value returned by $CONFIG: empty list\n" unless @PS1;
die "invalid prompt value returned by $CONFIG: undef value\n" unless defined $PS1[0];

print STDERR "${NAME}'s config: $CONFIG\n" if $DEBUG{config};


@PS1 = reduce @PS1;


if ($RUN_TEST || -t STDOUT) {
    die "TERM is not set\n" unless exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

    unless ($ENCODING) {
        warn "Encoding not set in locale. Please set LC_CTYPE.\n";
    } elsif ($ENCODING !~ /^UTF-/i) {
        # Get the canonical name
        $ENCODING = Encode::find_encoding($ENCODING)->name;
        warn "Your locale is not set to a known Unicode encoding (such as 'UTF-8') but to '$ENCODING'. Please report your use case to the Angel PS1 developers.\n"
    }

    if ($RUN_TEST) {
        require Cwd;
        my @x = reduce(expand({ '?' => 0, PWD => Cwd::cwd() }, @PS1));
        print AngelPS1::Shell->ps1_finalize(scalar reduce(@x)), "\n"
            if $RUN_TEST > 1;
        exit 0;
    }

    #print Red, "Red!", Reset, "\n";

    print "angel-PS1 $VERSION\n";

    my $script = index($0, '/') >= 0 ? $0 : "\$(which $FindBin::Script)";
    print "Copyright (C) 2013-2016  Olivier Mengué\n",
          "This program comes with ABSOLUTELY NO WARRANTY;\n",
          "This is free software, and you are welcome to redistribute it\n",
          "under certain conditions;\n",
          "Run \"sed -n '2,19{s/.//;p}' $script | iconv -f UTF-8\" for details.\n\n";
    print STDERR "usage: eval ".($shell eq 'fish' ? "($0)" : "`$0`")
               . "\n\nSee 'perldoc angel-PS1' for detailed help.\n";

    #print 'Running as an app: ', $APP, "\n";
    #print "\$Bin: $FindBin::Bin\n";
    #print "\$Script: $FindBin::Script\n";
    #print '__FILE__: ', __FILE__, "\n";
    #print "\%INC:\n  - ", join("\n  - ", sort keys %INC), "\n";
    #print "\@INC:\n  - ", join("\n  - ", @INC), "\n";

    exit 1;
}

# *****************************************************************************
# Angel startup
# *****************************************************************************

# No terminal? This is not an interactive shell.
# So we don't install.
exit 0 unless -t STDIN && exists $ENV{'TERM'} && $ENV{'TERM'} ne '';

# If the prompt is static after reduce(), just output it and don't install the
# angel. This allows the user to use the power of the angel-PS1 prompt compiler
# and plugins without the runtime cost.
if (ps1_is_static(\@PS1)
    and my $shell_code_static = AngelPS1::Shell->can('shell_code_static')) {

    (my $PS1 = ${$PS1[0]}) =~ s/'/'\\''/g;

    print AngelPS1::Shell->$shell_code_static(
        $PS1,
        name  => $NAME,
        debug => \%DEBUG,
    );

    exit 0
}


# Build the FIFO paths
my $FIFO_PATH = POSIX::tmpnam().".$NAME-$$";
my $FIFO_IN = "$FIFO_PATH.in";
my $FIFO_OUT = "$FIFO_PATH.out";


POSIX::mkfifo($FIFO_IN, 0600) or die "Can't create fifo $FIFO_IN: $!";
POSIX::mkfifo($FIFO_OUT, 0600) or die "Can't create fifo $FIFO_OUT: $!";
-p $FIFO_IN && -o _ or die "Fifo $FIFO_IN creation failed.";
-p $FIFO_OUT && -o _ or die "Fifo $FIFO_OUT creation failed.";

my $child = fork();
die if $child == -1;
if ($child) {
    print AngelPS1::Shell->shell_code_dynamic(
        name  => $NAME,
        debug => \%DEBUG,
        in    => $FIFO_IN,
        out   => $FIFO_OUT,
        env   => [qw< PWD >],
        pid   => $child,
    );

    print STDERR "$NAME installed.\n" unless $VERBOSE < 0;

    # We don't want the fifos to be removed by the END block
    undef $FIFO_IN;
    undef $FIFO_OUT;

    exit 0;
}

# *****************************************************************************
# Angel forked
# *****************************************************************************

$0 = qq{$FindBin::Script $NAME};

open STDIN, '+<', '/dev/null';
close STDOUT;
open STDOUT, '>', '/dev/null';

# Signals handling
# Reference: http://www.linusakesson.net/programming/tty/
#
# Ignore ^C sent to the terminal
$SIG{INT} = 'IGNORE';
# Let us keep writing to the terminal while in the background
# This is the default when 'stty -tostop'
$SIG{TTOU} = 'IGNORE';
# SIGWINCH is also handled in AngelPS1::Plugn::Term::Size
#
# Clean exits that will call our END block
$SIG{HUP} = $SIG{TERM} = sub { exit 0 };



# PS1 fallback, if something goes wrong with the user defined prompt
my $PS1_fallback = do {
    my @fallback = reduce(
        "[$NAME sick!] ",
        AngelPS1::Shell->WorkingDir,
        AngelPS1::Shell->UserPrivSymbol,
        ' ',
    );

        ps1_is_static(\@fallback)
    ? do { my $fallback = ${$fallback[0]}; sub { $fallback } }
    : sub { scalar reduce(expand(@_, @fallback)) }
};


# *****************************************************************************
# Angel main loop
# *****************************************************************************
sub main_loop
{
    my @PS1 = @_;

    my $FIFO;
    my %prompt_state;
    my ($k, $v);
    my ($open_in, $open_out) = (
        "<:encoding($ENCODING)",
        ">:encoding($ENCODING)",
    );

    # Make all paths in @INC absolute because we will change cwd
    require Cwd;
    my $cwd = Cwd::getcwd();
    foreach (@INC) {
        next if ref $_;
        $_ = File::Spec->rel2abs($_, $cwd);
    }

    require Errno;

    for (;;) {
        # Move to a safe directory to avoid blocking fs unmount
        chdir '/';

        unless (open $FIFO, $open_in, $FIFO_IN) {
            warn "Can't open $FIFO_IN (", 0+$!, "): $!\n" if $! != Errno::EINTR();
            redo if -e $FIFO_IN && -p _;
            last;
        }
        $_ = do { local $/; <$FIFO> };
        close $FIFO;
        printf STDERR "DEBUG< %s\n", do { (my $tmp = $_) =~ s/\0/ /g; $tmp } if $DEBUG{'in'};

        #my @shell_keys;
        foreach (split /\0/) {
            ($k, $v) = m/^(.*?)=(.*)/s;
            #push @shell_keys, $k;
            $prompt_state{$k} = $v;
        }

        chdir $prompt_state{'PWD'} if $prompt_state{'PWD'};

        my $PS1 = eval { reduce(expand(\%prompt_state, @PS1)) };
        unless (defined $PS1) {
            (my $err = $@) =~ s/\s*$//s;
            print STDERR ((Red + Bold)->term, $NAME, " PS1 eval: ", $err, Reset->term, "\n");
            $PS1 = $PS1_fallback->(\%prompt_state);
        }

        open $FIFO, $open_out, $FIFO_OUT;
        print $FIFO AngelPS1::Shell->ps1_finalize($PS1);
        close $FIFO;

        # Cleanup for next iteration, but so far the keys of shell_state
        # are always the same
        #delete @prompt_state{@shell_keys};
    }
}

main_loop(@PS1);

END {
    no warnings 'uninitialized';
    unlink $FIFO_IN, $FIFO_OUT;
}

__END__

=encoding utf-8

=head1 NAME

angel-PS1 - The Angel's Prompt

=head1 SYNOPSIS

Install a prompt (bash/mksh/dash/tcsh/ksh93):

    eval `angel-PS1 [--name <name>] [-I <dir>] [-p <prompt> | -c <config>]`

Install a prompt (fish):

    eval (angel-PS1 [--name <name>] [-I <dir>] [-p <prompt> | -c <config>])

Test a prompt definition (check that it can be compiled):

    angel-PS1 [--name <name>] [-I <dir>] [-p <prompt> | -c <config>]
              [--shell <shell>] --test

=head1 CONFIGURATION

The default prompt definition comes from the C<AngelPS1::Prompt::Default>
Perl module that is embeded in C<angel-PS1>.

You can use also your own prompt definition defined in a separate file.
I<No documentation yet>.

The prompt definition is searched as a file in perl's standard C<@INC> to which
F<$XDG_CONFIG_DIR/angel-PS1> (with fallback to F<$HOME/.config/angel-PS1>)
and F</etc/xdg/angel-PS1> have been preprended. See option C<-I> to prepend
more paths.

The following settings are used to determine the path/name of the file relative
to an C<@INC> directory (I<C<$ANGEL>> is the name of the angel (see the
C<--name> option, C<angel> is the default)):

=over 4

=item *

if I<C<$PROMPT>> is set with the C<--prompt> option:

=over 4

=item -

the C<AngelPS1::Prompt::I<$PROMPT>> perl module:
F<AngelPS1/Prompt/I<$PROMPT>.pm>

=item -

the F<I<$PROMPT>.PS1> file

=back

=item *

if C<--config I<$CONFIG>> option is given, the F<I<$CONFIG>> file

=item *

the C<AngelPS1::Prompt::I<$ANGEL>> perl module:
F<AngelPS1/Prompt/I<$ANGEL>.pm>

=item *

the F<I<$ANGEL>.PS1> file

=back

=head1 SHELLS

angel-PS1 is compatible with:

=over 4

=item *

bash

=item *

zsh

=item *

mksh

=item *

dash

=item *

fish

=back

=head1 SEE ALSO

=over 4

=item *

L<Liquid Prompt|https://github.com/nojhan/liquidprompt>

=item *

L<Powerline-shell|https://github.com/milkbikis/powerline-shell>

=back

=head1 SUPPORT

Announces of new releases: L<https://twitter.com/nglPS1>

Bug tracker: L<https://github.com/dolmen/angel-PS1/issues>

Interactive support using IRC: L<irc://irc.perl.org#angel-PS1>

=head1 AUTHOR

Olivier Mengué, L<mailto:dolmen@cpan.org>

=head1 COPYRIGHT & LICENSE

See the header of this file.

=cut

# vim:set et ts=8 sw=4 sts=4:
